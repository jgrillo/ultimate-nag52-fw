
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'VG'
*/

#ifdef EGS_SPRINTER_MODE

#ifndef __ECU_VG_H_
#define __ECU_VG_H_

#include <stdint.h>
    
#define VG_428_CAN_ID 0x0428

/** Current gear distribution gear */
enum class VG_428h_VG_GANG {
	SNV = 255, // unknown
};

/** status front axle */
enum class VG_428h_VG_VA_ST {
	SNV = 255, // unknown
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of VG_428 */
	uint32_t get_canid(){ return VG_428_CAN_ID; }
    /** Sets Terms of Use not met (Shift Impossible) */
    void set_SH_IMP(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Terms of Use not met (Shift Impossible) */
    bool get_SH_IMP() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets terrain Involampe (Low Lamp) */
    void set_VG_LOL(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets terrain Involampe (Low Lamp) */
    bool get_VG_LOL() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Error VG (ECU Failure Detected) */
    void set_VG_ERR(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Error VG (ECU Failure Detected) */
    bool get_VG_ERR() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets shifting canceled (Shift Aborted) */
    void set_SH_ABTD(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets shifting canceled (Shift Aborted) */
    bool get_SH_ABTD() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Current gear distribution gear */
    void set_VG_GANG(VG_428h_VG_GANG value){ raw = (raw & 0xf8ffffffffffffff) | ((uint64_t)value & 0x7) << 56; }

    /** Gets Current gear distribution gear */
    VG_428h_VG_GANG get_VG_GANG() const { return (VG_428h_VG_GANG)(raw >> 56 & 0x7); }
        
    /** Sets Toggle bit */
    void set_VG_TGL(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Toggle bit */
    bool get_VG_TGL() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Front Axle: Shift in Progress */
    void set_VG_VA_SIP(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Front Axle: Shift in Progress */
    bool get_VG_VA_SIP() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Metri-strand coupled across */
    void set_VG_LOCK_Y(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Metri-strand coupled across */
    bool get_VG_LOCK_Y() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets status front axle */
    void set_VG_VA_ST(VG_428h_VG_VA_ST value){ raw = (raw & 0xffffe7ffffffffff) | ((uint64_t)value & 0x3) << 43; }

    /** Gets status front axle */
    VG_428h_VG_VA_ST get_VG_VA_ST() const { return (VG_428h_VG_VA_ST)(raw >> 43 & 0x3); }
        
    /** Sets Fzg. With reduction gear */
    void set_VG_FZG_UG(bool value){ raw = (raw & 0xfffffbffffffffff) | ((uint64_t)value & 0x1) << 42; }

    /** Gets Fzg. With reduction gear */
    bool get_VG_FZG_UG() const { return (bool)(raw >> 42 & 0x1); }
        
    /** Sets Fzg. With coupling bar */
    void set_VG_FZG_LOCK(bool value){ raw = (raw & 0xfffffdffffffffff) | ((uint64_t)value & 0x1) << 41; }

    /** Gets Fzg. With coupling bar */
    bool get_VG_FZG_LOCK() const { return (bool)(raw >> 41 & 0x1); }
        
    /** Sets Fzg. With switch-off front axle */
    void set_VG_FZG_VA(bool value){ raw = (raw & 0xfffffeffffffffff) | ((uint64_t)value & 0x1) << 40; }

    /** Gets Fzg. With switch-off front axle */
    bool get_VG_FZG_VA() const { return (bool)(raw >> 40 & 0x1); }
        
} VG_428;



class ECU_VG {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case VG_428_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to VG_428
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_VG_428(uint64_t now, uint64_t max_expire_time, VG_428* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[1];
		uint64_t LAST_FRAME_TIMES[1];
};
#endif // __ECU_VG_H_

#endif // EGS_SPRINTER_MODE