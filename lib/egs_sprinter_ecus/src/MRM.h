
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'MRM'
*/

#ifdef EGS_SPRINTER_MODE

#ifndef __ECU_MRM_H_
#define __ECU_MRM_H_

#include <stdint.h>
    
#define MRM_A2_CAN_ID 0x04C1
#define MRM_A1_CAN_ID 0x04C0
#define MRM_238_CAN_ID 0x0238
#define LRW_236_CAN_ID 0x0236

/** steering angle */
enum class MRM_A1_LW_B {
	SNV = 255, // unknown
};

/** steering angle */
enum class MRM_238h_LW {
	SNV = 255, // unknown
};

/** steering wheel angle */
enum class LRW_236h_LRW {
	SNV = 255, // unknown
};

/** steering wheel angular velocity */
enum class LRW_236h_VLRW {
	SNV = 255, // unknown
};

/** Identification Steering wheel angle sensor */
enum class LRW_236h_LRWS_ID {
	INIT_PSBL = 0, // unknown
	INIT_SELF = 1, // unknown
	INIT_MUST = 2, // unknown
	SNV = 3, // unknown
};

/** Status steering wheel angle sensor */
enum class LRW_236h_LRWS_ST {
	OK = 0, // unknown
	INI = 1, // unknown
	ERR = 2, // unknown
	ERR_INI = 3, // unknown
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MRM_A2 */
	uint32_t get_canid(){ return MRM_A2_CAN_ID; }
    /** Sets Button right down */
    void set_WIPPE_4_2(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Button right down */
    bool get_WIPPE_4_2() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Button right bottom to top */
    void set_WIPPE_4_1(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Button right bottom to top */
    bool get_WIPPE_4_1() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Button top to bottom */
    void set_WIPPE_3_2(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Button top to bottom */
    bool get_WIPPE_3_2() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Button top to top */
    void set_WIPPE_3_1(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Button top to top */
    bool get_WIPPE_3_1() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets button lower left down */
    void set_WIPPE_2_2(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets button lower left down */
    bool get_WIPPE_2_2() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Button left top */
    void set_WIPPE_2_1(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Button left top */
    bool get_WIPPE_2_1() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Button left top */
    void set_WIPPE_1_2(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Button left top */
    bool get_WIPPE_1_2() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Button left top */
    void set_WIPPE_1_1(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Button left top */
    bool get_WIPPE_1_1() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Reserve */
    void set_WIPPE_8_2(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Reserve */
    bool get_WIPPE_8_2() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets Reserve */
    void set_WIPPE_8_1(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets Reserve */
    bool get_WIPPE_8_1() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets Reserve */
    void set_WIPPE_7_2(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets Reserve */
    bool get_WIPPE_7_2() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets Reserve */
    void set_WIPPE_7_1(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets Reserve */
    bool get_WIPPE_7_1() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets Reserve */
    void set_WIPPE_6_2(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets Reserve */
    bool get_WIPPE_6_2() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets Reserve */
    void set_WIPPE_6_1(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets Reserve */
    bool get_WIPPE_6_1() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets Reserve */
    void set_WIPPE_5_2(bool value){ raw = (raw & 0xfffdffffffffffff) | ((uint64_t)value & 0x1) << 49; }

    /** Gets Reserve */
    bool get_WIPPE_5_2() const { return (bool)(raw >> 49 & 0x1); }
        
    /** Sets Reserve */
    void set_WIPPE_5_1(bool value){ raw = (raw & 0xfffeffffffffffff) | ((uint64_t)value & 0x1) << 48; }

    /** Gets Reserve */
    bool get_WIPPE_5_1() const { return (bool)(raw >> 48 & 0x1); }
        
} MRM_A2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MRM_A1 */
	uint32_t get_canid(){ return MRM_A1_CAN_ID; }
    /** Sets Turn on the signal horn */
    void set_SGH_EIN_LR(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Turn on the signal horn */
    bool get_SGH_EIN_LR() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Turn on light horn */
    void set_LHP_EIN(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Turn on light horn */
    bool get_LHP_EIN() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Turn on high beam */
    void set_FL_EIN(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Turn on high beam */
    bool get_FL_EIN() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Turn turn signal lever directional flashing right */
    void set_BLIH_RE_BET(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Turn turn signal lever directional flashing right */
    bool get_BLIH_RE_BET() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets turn signal lever direction flashing left */
    void set_BLIH_LI_BET(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets turn signal lever direction flashing left */
    bool get_BLIH_LI_BET() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets LSS in position III (level 2) */
    void set_SCH_WI_2(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets LSS in position III (level 2) */
    bool get_SCH_WI_2() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets LSS in position II (level 1) */
    void set_SCH_WI_1(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets LSS in position II (level 1) */
    bool get_SCH_WI_1() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets LSS in position I (rain sensor operation) */
    void set_SCH_WI_INT(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets LSS in position I (rain sensor operation) */
    bool get_SCH_WI_INT() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets Wash actuated */
    void set_WASCHEN(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets Wash actuated */
    bool get_WASCHEN() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets Tippwuck actuated */
    void set_TIPP_WISCH(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets Tippwuck actuated */
    bool get_TIPP_WISCH() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets Steering angle Parity Bit (straight parity) */
    void set_LW_PA_B(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Steering angle Parity Bit (straight parity) */
    bool get_LW_PA_B() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Steering angle sensor: overflow */
    void set_LW_OV_B(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Steering angle sensor: overflow */
    bool get_LW_OV_B() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Steering angle sensor: Code error */
    void set_LW_CF_B(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets Steering angle sensor: Code error */
    bool get_LW_CF_B() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Steering angle sensor: not initialized */
    void set_LW_INI_B(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Steering angle sensor: not initialized */
    bool get_LW_INI_B() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets Steering angle sign */
    void set_LW_VZ_B(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets Steering angle sign */
    bool get_LW_VZ_B() const { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets steering angle */
    void set_LW_B(MRM_A1_LW_B value){ raw = (raw & 0xfffffff800ffffff) | ((uint64_t)value & 0x7ff) << 24; }

    /** Gets steering angle */
    MRM_A1_LW_B get_LW_B() const { return (MRM_A1_LW_B)(raw >> 24 & 0x7ff); }
        
    /** Sets rear window interval wiping */
    void set_HECK_INT(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets rear window interval wiping */
    bool get_HECK_INT() const { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets Wipe / wash rear window */
    void set_HECK_WISCH(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets Wipe / wash rear window */
    bool get_HECK_WISCH() const { return (bool)(raw >> 22 & 0x1); }
        
} MRM_A1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MRM_238 */
	uint32_t get_canid(){ return MRM_238_CAN_ID; }
    /** Sets Tempomat selector lever unplausible */
    void set_WH_UP(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Tempomat selector lever unplausible */
    bool get_WH_UP() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Operation variable speed limitation */
    void set_VMAX_AKT(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Operation variable speed limitation */
    bool get_VMAX_AKT() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Tempomat selector lever: 'Setting and delaying Levo0' */
    void set_S_MINUS_B(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Tempomat selector lever: 'Setting and delaying Levo0' */
    bool get_S_MINUS_B() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Tempomat selector lever: 'Put and Accelerate Level0' */
    void set_S_PLUS_B(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Tempomat selector lever: 'Put and Accelerate Level0' */
    bool get_S_PLUS_B() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Cruise control lever: 'Resumption' */
    void set_WA(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Cruise control lever: 'Resumption' */
    bool get_WA() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Tempomat selector lever: 'Switch off' */
    void set_AUS(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Tempomat selector lever: 'Switch off' */
    bool get_AUS() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Tempomatwahl lever Parity (straight parity) */
    void set_WH_PA(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets Tempomatwahl lever Parity (straight parity) */
    bool get_WH_PA() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets Message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_BZ238h(uint8_t value){ raw = (raw & 0xfff0ffffffffffff) | ((uint64_t)value & 0xf) << 48; }

    /** Gets Message counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_BZ238h() const { return (uint8_t)(raw >> 48 & 0xf); }
        
    /** Sets steering angle parity (straight parity) */
    void set_LW_PA(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets steering angle parity (straight parity) */
    bool get_LW_PA() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Steering angle sensor: overflow */
    void set_LW_OV(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Steering angle sensor: overflow */
    bool get_LW_OV() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Steering angle sensor: Code error */
    void set_LW_CF(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Steering angle sensor: Code error */
    bool get_LW_CF() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets Steering angle sensor: not initialized */
    void set_LW_INI(bool value){ raw = (raw & 0xffffefffffffffff) | ((uint64_t)value & 0x1) << 44; }

    /** Gets Steering angle sensor: not initialized */
    bool get_LW_INI() const { return (bool)(raw >> 44 & 0x1); }
        
    /** Sets Steering angle sign */
    void set_LW_VZ(bool value){ raw = (raw & 0xfffff7ffffffffff) | ((uint64_t)value & 0x1) << 43; }

    /** Gets Steering angle sign */
    bool get_LW_VZ() const { return (bool)(raw >> 43 & 0x1); }
        
    /** Sets steering angle */
    void set_LW(MRM_238h_LW value){ raw = (raw & 0xfffff800ffffffff) | ((uint64_t)value & 0x7ff) << 32; }

    /** Gets steering angle */
    MRM_238h_LW get_LW() const { return (MRM_238h_LW)(raw >> 32 & 0x7ff); }
        
} MRM_238;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of LRW_236 */
	uint32_t get_canid(){ return LRW_236_CAN_ID; }
    /** Sets steering wheel angle */
    void set_LRW(LRW_236h_LRW value){ raw = (raw & 0xc000ffffffffffff) | ((uint64_t)value & 0x3fff) << 48; }

    /** Gets steering wheel angle */
    LRW_236h_LRW get_LRW() const { return (LRW_236h_LRW)(raw >> 48 & 0x3fff); }
        
    /** Sets steering wheel angular velocity */
    void set_VLRW(LRW_236h_VLRW value){ raw = (raw & 0xffffc000ffffffff) | ((uint64_t)value & 0x3fff) << 32; }

    /** Gets steering wheel angular velocity */
    LRW_236h_VLRW get_VLRW() const { return (LRW_236h_VLRW)(raw >> 32 & 0x3fff); }
        
    /** Sets Message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_BZ236h(uint8_t value){ raw = (raw & 0xffffffff0fffffff) | ((uint64_t)value & 0xf) << 28; }

    /** Gets Message counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_BZ236h() const { return (uint8_t)(raw >> 28 & 0xf); }
        
    /** Sets Identification Steering wheel angle sensor */
    void set_LRWS_ID(LRW_236h_LRWS_ID value){ raw = (raw & 0xfffffffff3ffffff) | ((uint64_t)value & 0x3) << 26; }

    /** Gets Identification Steering wheel angle sensor */
    LRW_236h_LRWS_ID get_LRWS_ID() const { return (LRW_236h_LRWS_ID)(raw >> 26 & 0x3); }
        
    /** Sets Status steering wheel angle sensor */
    void set_LRWS_ST(LRW_236h_LRWS_ST value){ raw = (raw & 0xfffffffffcffffff) | ((uint64_t)value & 0x3) << 24; }

    /** Gets Status steering wheel angle sensor */
    LRW_236h_LRWS_ST get_LRWS_ST() const { return (LRW_236h_LRWS_ST)(raw >> 24 & 0x3); }
        
    /** Sets CRC checksum byte 1 - 7 to SAE J1850. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_CRC236h(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets CRC checksum byte 1 - 7 to SAE J1850. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_CRC236h() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} LRW_236;



class ECU_MRM {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case MRM_A2_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case MRM_A1_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case MRM_238_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case LRW_236_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to MRM_A2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MRM_A2(uint64_t now, uint64_t max_expire_time, MRM_A2* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to MRM_A1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MRM_A1(uint64_t now, uint64_t max_expire_time, MRM_A1* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to MRM_238
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MRM_238(uint64_t now, uint64_t max_expire_time, MRM_238* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to LRW_236
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_LRW_236(uint64_t now, uint64_t max_expire_time, LRW_236* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[4];
		uint64_t LAST_FRAME_TIMES[4];
};
#endif // __ECU_MRM_H_

#endif // EGS_SPRINTER_MODE