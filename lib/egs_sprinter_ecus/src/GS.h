
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'GS'
*/

#ifdef EGS_SPRINTER_MODE

#ifndef __ECU_GS_H_
#define __ECU_GS_H_

#include <stdint.h>
    
#define TCM_A2_CAN_ID 0x02E2
#define SBW_ANZ_GS_CAN_ID 0x03A0
#define SBW_23A_CAN_ID 0x023A
#define GS_418_CAN_ID 0x0418
#define GS_338_CAN_ID 0x0338
#define GS_218_CAN_ID 0x0218

/** Requested Current Duty Cycle */
enum class TCM_A2_CurrDtyCyc_Rq {
	SNV = 255, // unknown
};

/** Mode 1: State (Torque Converter Lockup) Clutch for Stop / Start Automatic (Monitor Layer) */
enum class TCM_A2_SSA_Clutch_Stat {
	DSABL = 0, // unknown
	ENBL = 1, // unknown
	NDEF2 = 2, // unknown
};

/** Actual Transmission Slip RPM */
enum class TCM_A2_TxSlpRPM {
	SNV = 255, // unknown
};

/** Desired Transmission Slip */
enum class TCM_A2_TxSlpRPM_Dsr {
	SNV = 255, // unknown
};

/** Error Check State */
enum class TCM_A2_TCM_ErrChk_Stat {
	WAIT = 0, // unknown
	OK = 1, // unknown
	ERROR = 2, // unknown
};

/** drive */
enum class SBW_ANZ_GS_FSC_GS {
	M1 = 1, // unknown
	M2 = 2, // unknown
	M3 = 3, // unknown
	M4 = 4, // unknown
	M5 = 5, // unknown
	M6 = 6, // unknown
	M7 = 7, // unknown
	BLANK = 32, // unknown
	D1 = 49, // unknown
	D2 = 50, // unknown
	D3 = 51, // unknown
	D4 = 52, // unknown
	D5 = 53, // unknown
	D6 = 54, // unknown
	D7 = 55, // unknown
	A = 65, // unknown
	D = 68, // unknown
	F = 70, // unknown
	N = 78, // unknown
	P = 80, // unknown
	R = 82, // unknown
	SNV = 255, // unknown
};

/** Driving program */
enum class SBW_ANZ_GS_FPC_GS {
	BLANK = 32, // unknown
	A = 65, // unknown
	C = 67, // unknown
	E = 69, // unknown
	F = 70, // unknown
	M = 77, // unknown
	S = 83, // unknown
	W = 87, // unknown
	SNV = 255, // unknown
};

/** Request Display Transmission Description */
enum class SBW_ANZ_GS_GETR_SCH_E_GS {
	IDLE = 0, // unknown
	UP = 1, // unknown
	DOWN = 2, // unknown
	SNV = 3, // unknown
};

/** Messages Shift by Wire */
enum class SBW_ANZ_GS_SBW_DSPL_GS {
	KEIN = 0, // unknown
	M1 = 1, // unknown
	M2 = 2, // unknown
	M3 = 3, // unknown
	M4 = 4, // unknown
	M5 = 5, // unknown
	M6 = 6, // unknown
};

/** Display Motion lock 2 area dialing lever */
enum class SBW_ANZ_GS_BWH_SPERR2_GS {
	IDLE = 0, // unknown
	PFEIL_OB = 1, // unknown
	PFEIL_UN = 2, // unknown
	PFEIL_LI = 3, // unknown
	PFEIL_OB_UN = 4, // unknown
	PFEIL_OB_HV = 9, // unknown
	PFEIL_UN_HV = 10, // unknown
	PFEIL_LI_HV = 11, // unknown
	PFEIL_OB_UN_HV = 12, // unknown
};

/** Display Motion lock 1 area dialing lever */
enum class SBW_ANZ_GS_BWH_SPERR1_GS {
	IDLE = 0, // unknown
	PFEIL_OB = 1, // unknown
	PFEIL_UN = 2, // unknown
	PFEIL_LI = 3, // unknown
	PFEIL_OB_UN = 4, // unknown
	PFEIL_OB_HV = 9, // unknown
	PFEIL_UN_HV = 10, // unknown
	PFEIL_LI_HV = 11, // unknown
	PFEIL_OB_UN_HV = 12, // unknown
};

/** Display Movement lock 4 Range dial lever */
enum class SBW_ANZ_GS_BWH_SPERR4_GS {
	IDLE = 0, // unknown
	PFEIL_OB = 1, // unknown
	PFEIL_UN = 2, // unknown
	PFEIL_LI = 3, // unknown
	PFEIL_OB_UN = 4, // unknown
	PFEIL_OB_HV = 9, // unknown
	PFEIL_UN_HV = 10, // unknown
	PFEIL_LI_HV = 11, // unknown
	PFEIL_OB_UN_HV = 12, // unknown
};

/** Display movement lock 3 area dial lever */
enum class SBW_ANZ_GS_BWH_SPERR3_GS {
	IDLE = 0, // unknown
	PFEIL_OB = 1, // unknown
	PFEIL_UN = 2, // unknown
	PFEIL_LI = 3, // unknown
	PFEIL_OB_UN = 4, // unknown
	PFEIL_OB_HV = 9, // unknown
	PFEIL_UN_HV = 10, // unknown
	PFEIL_LI_HV = 11, // unknown
	PFEIL_OB_UN_HV = 12, // unknown
};

/** Request display Destination */
enum class SBW_ANZ_GS_ANZ_ZIELGNG_GS {
	BLANK = 32, // unknown
	G1 = 49, // unknown
	G2 = 50, // unknown
	G3 = 51, // unknown
	G4 = 52, // unknown
	G5 = 53, // unknown
	G6 = 54, // unknown
	G7 = 55, // unknown
	FEHLER = 70, // unknown
	SNV = 255, // unknown
};

/** Display start with max. Acceleration */
enum class SBW_ANZ_GS_RACE_START_ANZ {
	PASSIV = 0, // unknown
	RACESTART_VERF = 1, // unknown
	RACESTART_AKT = 2, // unknown
	RACESTART_LFT = 3, // unknown
	ABBRUCH = 4, // unknown
	N_RACESTART = 5, // unknown
	RACESTART_BEST = 6, // unknown
	SNA = 7, // unknown
};

/** transmitter recognition */
enum class SBW_23Ah_SID_SBW_GS {
	VGS = 0, // unknown
	EGS = 1, // unknown
	HYBRID = 2, // unknown
	NA = 3, // unknown
};

/** IM position selector range slide in the gearbox */
enum class SBW_23Ah_WBS_ST {
	D = 5, // unknown
	N = 6, // unknown
	R = 7, // unknown
	P = 8, // unknown
	N_ZW_D = 11, // unknown
	R_ZW_N = 12, // unknown
	P_ZW_R = 13, // unknown
	SNV = 15, // unknown
};

/** Setpoint area selection lever */
enum class SBW_23Ah_BWHST_SOLL {
	IDLE = 0, // unknown
	D = 5, // unknown
	N = 6, // unknown
	R = 7, // unknown
	P = 8, // unknown
	SNV = 15, // unknown
};

/** Value Selector Sensor */
enum class SBW_23Ah_WBS_POS {
	SNV = 255, // unknown
};

/** drive */
enum class GS_418h_FSC {
	BLANK = 32, // unknown
	EINS = 49, // unknown
	ZWEI = 50, // unknown
	DREI = 51, // unknown
	VIER = 52, // unknown
	FUENF = 53, // unknown
	SECHS = 54, // unknown
	SIEBEN = 55, // unknown
	A = 65, // unknown
	D = 68, // unknown
	F = 70, // unknown
	N = 78, // unknown
	P = 80, // unknown
	R = 82, // unknown
	SNV = 255, // unknown
};

/** Driving program */
enum class GS_418h_FPC {
	C_MGFB_WT = 2, // unknown
	C_MGSNN = 3, // unknown
	C_MGBB = 4, // unknown
	C_MGGEA = 6, // unknown
	C_MGZSN = 7, // unknown
	A_MGFB_WT = 10, // unknown
	A_MGSNN = 11, // unknown
	A_MGBB = 12, // unknown
	A_MGGEA = 14, // unknown
	A_MGZSN = 15, // unknown
	S_MGFB_WT = 18, // unknown
	S_MGSNN = 19, // unknown
	S_MGBB = 20, // unknown
	S_MGGEA = 22, // unknown
	S_MGZSN = 23, // unknown
	HOCH = 24, // unknown
	RUNTER = 25, // unknown
	RACE_START = 26, // unknown
	BLANK = 32, // unknown
	BLANK_MGN = 64, // unknown
	A = 65, // unknown
	C = 67, // unknown
	F = 70, // unknown
	S = 83, // unknown
	S_PLUS = 84, // unknown
	W = 87, // unknown
	_ = 95, // unknown
	BLANK_MGW = 96, // unknown
	A_MGN = 97, // unknown
	C_MGN = 99, // unknown
	M_MGN = 109, // unknown
	S_MGN = 115, // unknown
	W_MGN = 119, // unknown
	UNDERSCORE_MGN = 127, // unknown
	A_MGW = 129, // unknown
	C_MGW = 131, // unknown
	F_MGW = 134, // unknown
	M_MGW = 141, // unknown
	S_MGW = 147, // unknown
	W_MGW = 151, // unknown
	UNDERSCORE_MGW = 159, // unknown
	SNV = 255, // unknown
};

/** Gear oil temperature */
enum class GS_418h_T_GET {
	SNV = 255, // unknown
};

/** Gear mechanics variant */
enum class GS_418h_MECH {
	GROSS = 0, // unknown
	KLEIN = 1, // unknown
	GROSS2 = 2, // unknown
	KLEIN2 = 3, // unknown
};

/** Goal Gang */
enum class GS_418h_GZC {
	N = 0, // unknown
	D1 = 1, // unknown
	D2 = 2, // unknown
	D3 = 3, // unknown
	D4 = 4, // unknown
	D5 = 5, // unknown
	D6 = 6, // unknown
	D7 = 7, // unknown
	D_CVT = 8, // unknown
	R_CVT = 9, // unknown
	R3 = 10, // unknown
	R = 11, // unknown
	R2 = 12, // unknown
	P = 13, // unknown
	ABBRUCH = 14, // unknown
	SNV = 15, // unknown
};

/** actual gear */
enum class GS_418h_GIC {
	N = 0, // unknown
	D1 = 1, // unknown
	D2 = 2, // unknown
	D3 = 3, // unknown
	D4 = 4, // unknown
	D5 = 5, // unknown
	D6 = 6, // unknown
	D7 = 7, // unknown
	D_CVT = 8, // unknown
	R_CVT = 9, // unknown
	R3 = 10, // unknown
	R = 11, // unknown
	R2 = 12, // unknown
	P = 13, // unknown
	KRAFTFREI = 14, // unknown
	SNV = 15, // unknown
};

/** Loss moment (FFH at KSG) */
enum class GS_418h_M_VERL {
	SNV = 255, // unknown
};

/** Gear Selection Library (NAG, KSG, CVT) */
enum class GS_418h_WHST {
	P = 0, // unknown
	R = 1, // unknown
	N = 2, // unknown
	D = 4, // unknown
	SNV = 7, // unknown
};

/** Factor wheel torque (7ffh at KSG) */
enum class GS_418h_FMRAD {
	SNV = 255, // unknown
};

/** Transmission output speed (only 463/461, otherwise FFFFH) */
enum class GS_338h_NAB {
	SNV = 255, // unknown
};

/** start with maximum acceleration */
enum class GS_338h_RACE_START {
	OFF = 0, // unknown
	ON = 1, // unknown
	ACTV = 2, // unknown
	SNA = 3, // unknown
};

/** pilot torque (0h: passive value) */
enum class GS_338h_M_VORSTR {
	SNV = 255, // unknown
};

/** Amount of the total side wave torque for starting area */
enum class GS_338h_MABS_SW_ANFB {
	SNV = 255, // unknown
};

/** Turbine speed (EGS52-NAG, VGS-NAG2) */
enum class GS_338h_NTURBINE {
	SNV = 255, // unknown
};

/** Ford. Engine torque */
enum class GS_218h_M_EGS {
	SNV = 255, // unknown
};

/** Goal Gang */
enum class GS_218h_GZC {
	N = 0, // unknown
	D1 = 1, // unknown
	D2 = 2, // unknown
	D3 = 3, // unknown
	D4 = 4, // unknown
	D5 = 5, // unknown
	D6 = 6, // unknown
	D7 = 7, // unknown
	D_CVT = 8, // unknown
	R_CVT = 9, // unknown
	R3 = 10, // unknown
	R = 11, // unknown
	R2 = 12, // unknown
	P = 13, // unknown
	ABBRUCH = 14, // unknown
	SNV = 15, // unknown
};

/** actual gear */
enum class GS_218h_GIC {
	N = 0, // unknown
	D1 = 1, // unknown
	D2 = 2, // unknown
	D3 = 3, // unknown
	D4 = 4, // unknown
	D5 = 5, // unknown
	D6 = 6, // unknown
	D7 = 7, // unknown
	D_CVT = 8, // unknown
	R_CVT = 9, // unknown
	R3 = 10, // unknown
	R = 11, // unknown
	R2 = 12, // unknown
	P = 13, // unknown
	KRAFTFREI = 14, // unknown
	SNV = 15, // unknown
};

/** Driving program for AAD */
enum class GS_218h_FPC_AAD_NEU {
	SPORT = 0, // unknown
	KOMFORT = 1, // unknown
	SPORT_PLUS = 2, // unknown
	OFFROAD = 6, // unknown
	SNV = 7, // unknown
};

/** Return mode transmission control */
enum class GS_218h_RS_Md_GS {
	IDLE = 0, // unknown
	EINF = 1, // unknown
	MEHRF = 2, // unknown
	UEBERW = 3, // unknown
};

/** Creep torque (FFH at EGS, CVT) or Calid / CVN */
enum class GS_218h_MKRIECH {
	SNV = 255, // unknown
};

/** status error check */
enum class GS_218h_FEHLPRF_ST {
	WAIT = 0, // unknown
	OK = 1, // unknown
	ERROR = 2, // unknown
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of TCM_A2 */
	uint32_t get_canid(){ return TCM_A2_CAN_ID; }
    /** Sets Requested Current Duty Cycle */
    void set_CurrDtyCyc_Rq(TCM_A2_CurrDtyCyc_Rq value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Requested Current Duty Cycle */
    TCM_A2_CurrDtyCyc_Rq get_CurrDtyCyc_Rq() const { return (TCM_A2_CurrDtyCyc_Rq)(raw >> 56 & 0xff); }
        
    /** Sets Enable Start / Stop Automatic Request */
    void set_SSA_Enbl_Rq_TCM(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Enable Start / Stop Automatic Request */
    bool get_SSA_Enbl_Rq_TCM() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets Mode 1: State (Torque Converter Lockup) Clutch for Stop / Start Automatic (Monitor Layer) */
    void set_SSA_Clutch_Stat(TCM_A2_SSA_Clutch_Stat value){ raw = (raw & 0xff9fffffffffffff) | ((uint64_t)value & 0x3) << 53; }

    /** Gets Mode 1: State (Torque Converter Lockup) Clutch for Stop / Start Automatic (Monitor Layer) */
    TCM_A2_SSA_Clutch_Stat get_SSA_Clutch_Stat() const { return (TCM_A2_SSA_Clutch_Stat)(raw >> 53 & 0x3); }
        
    /** Sets SSA Enabling Stat. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_SSA_Enbl_Stat_TCM(uint8_t value){ raw = (raw & 0xffff3fffffffffff) | ((uint64_t)value & 0x3) << 46; }

    /** Gets SSA Enabling Stat. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_SSA_Enbl_Stat_TCM() const { return (uint8_t)(raw >> 46 & 0x3); }
        
    /** Sets Actual Transmission Slip RPM */
    void set_TxSlpRPM(TCM_A2_TxSlpRPM value){ raw = (raw & 0xffffc000ffffffff) | ((uint64_t)value & 0x3fff) << 32; }

    /** Gets Actual Transmission Slip RPM */
    TCM_A2_TxSlpRPM get_TxSlpRPM() const { return (TCM_A2_TxSlpRPM)(raw >> 32 & 0x3fff); }
        
    /** Sets Desired Transmission Slip */
    void set_TxSlpRPM_Dsr(TCM_A2_TxSlpRPM_Dsr value){ raw = (raw & 0xffffffffc000ffff) | ((uint64_t)value & 0x3fff) << 16; }

    /** Gets Desired Transmission Slip */
    TCM_A2_TxSlpRPM_Dsr get_TxSlpRPM_Dsr() const { return (TCM_A2_TxSlpRPM_Dsr)(raw >> 16 & 0x3fff); }
        
    /** Sets Calid / CVN Data Byte. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_TCM_Data(uint8_t value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets Calid / CVN Data Byte. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_TCM_Data() const { return (uint8_t)(raw >> 8 & 0xff); }
        
    /** Sets Error Check State */
    void set_TCM_ErrChk_Stat(TCM_A2_TCM_ErrChk_Stat value){ raw = (raw & 0xffffffffffffff3f) | ((uint64_t)value & 0x3) << 6; }

    /** Gets Error Check State */
    TCM_A2_TCM_ErrChk_Stat get_TCM_ErrChk_Stat() const { return (TCM_A2_TCM_ErrChk_Stat)(raw >> 6 & 0x3); }
        
    /** Sets Calid / CVN Transmission Active */
    void set_TCM_CALID_CVN_Actv(bool value){ raw = (raw & 0xffffffffffffffdf) | ((uint64_t)value & 0x1) << 5; }

    /** Gets Calid / CVN Transmission Active */
    bool get_TCM_CALID_CVN_Actv() const { return (bool)(raw >> 5 & 0x1); }
        
    /** Sets Error Number Or Counter for Calid / CVN Transmission. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_TCM_CALID_CVN_ErrNum(uint8_t value){ raw = (raw & 0xffffffffffffffe0) | ((uint64_t)value & 0x1f) << 0; }

    /** Gets Error Number Or Counter for Calid / CVN Transmission. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_TCM_CALID_CVN_ErrNum() const { return (uint8_t)(raw >> 0 & 0x1f); }
        
} TCM_A2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SBW_ANZ_GS */
	uint32_t get_canid(){ return SBW_ANZ_GS_CAN_ID; }
    /** Sets drive */
    void set_FSC_GS(SBW_ANZ_GS_FSC_GS value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets drive */
    SBW_ANZ_GS_FSC_GS get_FSC_GS() const { return (SBW_ANZ_GS_FSC_GS)(raw >> 56 & 0xff); }
        
    /** Sets Driving program */
    void set_FPC_GS(SBW_ANZ_GS_FPC_GS value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Driving program */
    SBW_ANZ_GS_FPC_GS get_FPC_GS() const { return (SBW_ANZ_GS_FPC_GS)(raw >> 48 & 0xff); }
        
    /** Sets Warning Tone Shift by Wire */
    void set_SBW_WT_GS(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Warning Tone Shift by Wire */
    bool get_SBW_WT_GS() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Request Display Transmission Description */
    void set_GETR_SCH_E_GS(SBW_ANZ_GS_GETR_SCH_E_GS value){ raw = (raw & 0xffff9fffffffffff) | ((uint64_t)value & 0x3) << 45; }

    /** Gets Request Display Transmission Description */
    SBW_ANZ_GS_GETR_SCH_E_GS get_GETR_SCH_E_GS() const { return (SBW_ANZ_GS_GETR_SCH_E_GS)(raw >> 45 & 0x3); }
        
    /** Sets Messages Shift by Wire */
    void set_SBW_DSPL_GS(SBW_ANZ_GS_SBW_DSPL_GS value){ raw = (raw & 0xfffff8ffffffffff) | ((uint64_t)value & 0x7) << 40; }

    /** Gets Messages Shift by Wire */
    SBW_ANZ_GS_SBW_DSPL_GS get_SBW_DSPL_GS() const { return (SBW_ANZ_GS_SBW_DSPL_GS)(raw >> 40 & 0x7); }
        
    /** Sets Display Motion lock 2 area dialing lever */
    void set_BWH_SPERR2_GS(SBW_ANZ_GS_BWH_SPERR2_GS value){ raw = (raw & 0xffffff0fffffffff) | ((uint64_t)value & 0xf) << 36; }

    /** Gets Display Motion lock 2 area dialing lever */
    SBW_ANZ_GS_BWH_SPERR2_GS get_BWH_SPERR2_GS() const { return (SBW_ANZ_GS_BWH_SPERR2_GS)(raw >> 36 & 0xf); }
        
    /** Sets Display Motion lock 1 area dialing lever */
    void set_BWH_SPERR1_GS(SBW_ANZ_GS_BWH_SPERR1_GS value){ raw = (raw & 0xfffffff0ffffffff) | ((uint64_t)value & 0xf) << 32; }

    /** Gets Display Motion lock 1 area dialing lever */
    SBW_ANZ_GS_BWH_SPERR1_GS get_BWH_SPERR1_GS() const { return (SBW_ANZ_GS_BWH_SPERR1_GS)(raw >> 32 & 0xf); }
        
    /** Sets Display Movement lock 4 Range dial lever */
    void set_BWH_SPERR4_GS(SBW_ANZ_GS_BWH_SPERR4_GS value){ raw = (raw & 0xffffffff0fffffff) | ((uint64_t)value & 0xf) << 28; }

    /** Gets Display Movement lock 4 Range dial lever */
    SBW_ANZ_GS_BWH_SPERR4_GS get_BWH_SPERR4_GS() const { return (SBW_ANZ_GS_BWH_SPERR4_GS)(raw >> 28 & 0xf); }
        
    /** Sets Display movement lock 3 area dial lever */
    void set_BWH_SPERR3_GS(SBW_ANZ_GS_BWH_SPERR3_GS value){ raw = (raw & 0xfffffffff0ffffff) | ((uint64_t)value & 0xf) << 24; }

    /** Gets Display movement lock 3 area dial lever */
    SBW_ANZ_GS_BWH_SPERR3_GS get_BWH_SPERR3_GS() const { return (SBW_ANZ_GS_BWH_SPERR3_GS)(raw >> 24 & 0xf); }
        
    /** Sets Request display Destination */
    void set_ANZ_ZIELGNG_GS(SBW_ANZ_GS_ANZ_ZIELGNG_GS value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Request display Destination */
    SBW_ANZ_GS_ANZ_ZIELGNG_GS get_ANZ_ZIELGNG_GS() const { return (SBW_ANZ_GS_ANZ_ZIELGNG_GS)(raw >> 16 & 0xff); }
        
    /** Sets Display start with max. Acceleration */
    void set_RACE_START_ANZ(SBW_ANZ_GS_RACE_START_ANZ value){ raw = (raw & 0xffffffffffff1fff) | ((uint64_t)value & 0x7) << 13; }

    /** Gets Display start with max. Acceleration */
    SBW_ANZ_GS_RACE_START_ANZ get_RACE_START_ANZ() const { return (SBW_ANZ_GS_RACE_START_ANZ)(raw >> 13 & 0x7); }
        
} SBW_ANZ_GS;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SBW_23A */
	uint32_t get_canid(){ return SBW_23A_CAN_ID; }
    /** Sets transmitter recognition */
    void set_SID_SBW_GS(SBW_23Ah_SID_SBW_GS value){ raw = (raw & 0x3fffffffffffffff) | ((uint64_t)value & 0x3) << 62; }

    /** Gets transmitter recognition */
    SBW_23Ah_SID_SBW_GS get_SID_SBW_GS() const { return (SBW_23Ah_SID_SBW_GS)(raw >> 62 & 0x3); }
        
    /** Sets Still lock contact (only at EGS52) */
    void set_ASK(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Still lock contact (only at EGS52) */
    bool get_ASK() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets IM position selector range slide in the gearbox */
    void set_WBS_ST(SBW_23Ah_WBS_ST value){ raw = (raw & 0xff0fffffffffffff) | ((uint64_t)value & 0xf) << 52; }

    /** Gets IM position selector range slide in the gearbox */
    SBW_23Ah_WBS_ST get_WBS_ST() const { return (SBW_23Ah_WBS_ST)(raw >> 52 & 0xf); }
        
    /** Sets Setpoint area selection lever */
    void set_BWHST_SOLL(SBW_23Ah_BWHST_SOLL value){ raw = (raw & 0xfff0ffffffffffff) | ((uint64_t)value & 0xf) << 48; }

    /** Gets Setpoint area selection lever */
    SBW_23Ah_BWHST_SOLL get_BWHST_SOLL() const { return (SBW_23Ah_BWHST_SOLL)(raw >> 48 & 0xf); }
        
    /** Sets Value Selector Sensor */
    void set_WBS_POS(SBW_23Ah_WBS_POS value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Value Selector Sensor */
    SBW_23Ah_WBS_POS get_WBS_POS() const { return (SBW_23Ah_WBS_POS)(raw >> 40 & 0xff); }
        
    /** Sets Message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_BZ23Ah(uint8_t value){ raw = (raw & 0xffffffffffff0fff) | ((uint64_t)value & 0xf) << 12; }

    /** Gets Message counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_BZ23Ah() const { return (uint8_t)(raw >> 12 & 0xf); }
        
    /** Sets CRC checksum byte 1 - 7 to SAE J1850. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_CRC23Ah(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets CRC checksum byte 1 - 7 to SAE J1850. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_CRC23Ah() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} SBW_23A;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GS_418 */
	uint32_t get_canid(){ return GS_418_CAN_ID; }
    /** Sets drive */
    void set_FSC(GS_418h_FSC value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets drive */
    GS_418h_FSC get_FSC() const { return (GS_418h_FSC)(raw >> 56 & 0xff); }
        
    /** Sets Driving program */
    void set_FPC(GS_418h_FPC value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Driving program */
    GS_418h_FPC get_FPC() const { return (GS_418h_FPC)(raw >> 48 & 0xff); }
        
    /** Sets Gear oil temperature */
    void set_T_GET(GS_418h_T_GET value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Gear oil temperature */
    GS_418h_T_GET get_T_GET() const { return (GS_418h_T_GET)(raw >> 40 & 0xff); }
        
    /** Sets four-wheel drive */
    void set_ALLRAD(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets four-wheel drive */
    bool get_ALLRAD() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Front drive [1], rear drive [0] */
    void set_FRONT(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Front drive [1], rear drive [0] */
    bool get_FRONT() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets circuit */
    void set_SCHALT(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets circuit */
    bool get_SCHALT() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Stepless transmission [1], stage gear [0] */
    void set_CVT(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Stepless transmission [1], stage gear [0] */
    bool get_CVT() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets Gear mechanics variant */
    void set_MECH(GS_418h_MECH value){ raw = (raw & 0xfffffff3ffffffff) | ((uint64_t)value & 0x3) << 34; }

    /** Gets Gear mechanics variant */
    GS_418h_MECH get_MECH() const { return (GS_418h_MECH)(raw >> 34 & 0x3); }
        
    /** Sets Create brake when switching on */
    void set_ESV_BRE(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets Create brake when switching on */
    bool get_ESV_BRE() const { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets Goal Gang */
    void set_GZC(GS_418h_GZC value){ raw = (raw & 0xffffffff0fffffff) | ((uint64_t)value & 0xf) << 28; }

    /** Gets Goal Gang */
    GS_418h_GZC get_GZC() const { return (GS_418h_GZC)(raw >> 28 & 0xf); }
        
    /** Sets actual gear */
    void set_GIC(GS_418h_GIC value){ raw = (raw & 0xfffffffff0ffffff) | ((uint64_t)value & 0xf) << 24; }

    /** Gets actual gear */
    GS_418h_GIC get_GIC() const { return (GS_418h_GIC)(raw >> 24 & 0xf); }
        
    /** Sets Loss moment (FFH at KSG) */
    void set_M_VERL(GS_418h_M_VERL value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Loss moment (FFH at KSG) */
    GS_418h_M_VERL get_M_VERL() const { return (GS_418h_M_VERL)(raw >> 16 & 0xff); }
        
    /** Sets Factor wheel torque parity (straight parity) */
    void set_FMRADPAR(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Factor wheel torque parity (straight parity) */
    bool get_FMRADPAR() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets Factor wheel torque Toggle 40ms + -10 */
    void set_FMRADTGL(bool value){ raw = (raw & 0xffffffffffffbfff) | ((uint64_t)value & 0x1) << 14; }

    /** Gets Factor wheel torque Toggle 40ms + -10 */
    bool get_FMRADTGL() const { return (bool)(raw >> 14 & 0x1); }
        
    /** Sets Gear Selection Library (NAG, KSG, CVT) */
    void set_WHST(GS_418h_WHST value){ raw = (raw & 0xffffffffffffc7ff) | ((uint64_t)value & 0x7) << 11; }

    /** Gets Gear Selection Library (NAG, KSG, CVT) */
    GS_418h_WHST get_WHST() const { return (GS_418h_WHST)(raw >> 11 & 0x7); }
        
    /** Sets Factor wheel torque (7ffh at KSG) */
    void set_FMRAD(GS_418h_FMRAD value){ raw = (raw & 0xfffffffffffff800) | ((uint64_t)value & 0x7ff) << 0; }

    /** Gets Factor wheel torque (7ffh at KSG) */
    GS_418h_FMRAD get_FMRAD() const { return (GS_418h_FMRAD)(raw >> 0 & 0x7ff); }
        
} GS_418;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GS_338 */
	uint32_t get_canid(){ return GS_338_CAN_ID; }
    /** Sets Transmission output speed (only 463/461, otherwise FFFFH) */
    void set_NAB(GS_338h_NAB value){ raw = (raw & 0x0000ffffffffffff) | ((uint64_t)value & 0xffff) << 48; }

    /** Gets Transmission output speed (only 463/461, otherwise FFFFH) */
    GS_338h_NAB get_NAB() const { return (GS_338h_NAB)(raw >> 48 & 0xffff); }
        
    /** Sets Request Mil through GS */
    void set_MIL_ANF_GS(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Request Mil through GS */
    bool get_MIL_ANF_GS() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets NAK interface parity bit */
    void set_NAK_PA(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets NAK interface parity bit */
    bool get_NAK_PA() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets NAK interface Togglebit */
    void set_NAK_TGL(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets NAK interface Togglebit */
    bool get_NAK_TGL() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets function 'power-free in D' activated */
    void set_KID(bool value){ raw = (raw & 0xffffefffffffffff) | ((uint64_t)value & 0x1) << 44; }

    /** Gets function 'power-free in D' activated */
    bool get_KID() const { return (bool)(raw >> 44 & 0x1); }
        
    /** Sets start with maximum acceleration */
    void set_RACE_START(GS_338h_RACE_START value){ raw = (raw & 0xfffff3ffffffffff) | ((uint64_t)value & 0x3) << 42; }

    /** Gets start with maximum acceleration */
    GS_338h_RACE_START get_RACE_START() const { return (GS_338h_RACE_START)(raw >> 42 & 0x3); }
        
    /** Sets pilot torque (0h: passive value) */
    void set_M_VORSTR(GS_338h_M_VORSTR value){ raw = (raw & 0xfffffc00ffffffff) | ((uint64_t)value & 0x3ff) << 32; }

    /** Gets pilot torque (0h: passive value) */
    GS_338h_M_VORSTR get_M_VORSTR() const { return (GS_338h_M_VORSTR)(raw >> 32 & 0x3ff); }
        
    /** Sets Amount of the total side wave torque for starting area */
    void set_MABS_SW_ANFB(GS_338h_MABS_SW_ANFB value){ raw = (raw & 0xffffffff0000ffff) | ((uint64_t)value & 0xffff) << 16; }

    /** Gets Amount of the total side wave torque for starting area */
    GS_338h_MABS_SW_ANFB get_MABS_SW_ANFB() const { return (GS_338h_MABS_SW_ANFB)(raw >> 16 & 0xffff); }
        
    /** Sets Turbine speed (EGS52-NAG, VGS-NAG2) */
    void set_NTURBINE(GS_338h_NTURBINE value){ raw = (raw & 0xffffffffffff0000) | ((uint64_t)value & 0xffff) << 0; }

    /** Gets Turbine speed (EGS52-NAG, VGS-NAG2) */
    GS_338h_NTURBINE get_NTURBINE() const { return (GS_338h_NTURBINE)(raw >> 0 & 0xffff); }
        
} GS_338;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GS_218 */
	uint32_t get_canid(){ return GS_218_CAN_ID; }
    /** Sets Motor moments approach. Toggle 40ms + -10 */
    void set_MTGL_EGS(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Motor moments approach. Toggle 40ms + -10 */
    bool get_MTGL_EGS() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Motoroment request min */
    void set_MMIN_EGS(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Motoroment request min */
    bool get_MMIN_EGS() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Motoroment request max */
    void set_MMAX_EGS(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Motoroment request max */
    bool get_MMAX_EGS() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Ford. Engine torque */
    void set_M_EGS(GS_218h_M_EGS value){ raw = (raw & 0xe000ffffffffffff) | ((uint64_t)value & 0x1fff) << 48; }

    /** Gets Ford. Engine torque */
    GS_218h_M_EGS get_M_EGS() const { return (GS_218h_M_EGS)(raw >> 48 & 0x1fff); }
        
    /** Sets Goal Gang */
    void set_GZC(GS_218h_GZC value){ raw = (raw & 0xffff0fffffffffff) | ((uint64_t)value & 0xf) << 44; }

    /** Gets Goal Gang */
    GS_218h_GZC get_GZC() const { return (GS_218h_GZC)(raw >> 44 & 0xf); }
        
    /** Sets actual gear */
    void set_GIC(GS_218h_GIC value){ raw = (raw & 0xfffff0ffffffffff) | ((uint64_t)value & 0xf) << 40; }

    /** Gets actual gear */
    GS_218h_GIC get_GIC() const { return (GS_218h_GIC)(raw >> 40 & 0xf); }
        
    /** Sets Best. (Transducer overbridge.-) clutch 'slip' */
    void set_K_S_B(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Best. (Transducer overbridge.-) clutch 'slip' */
    bool get_K_S_B() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Best. (Transducer overbridge.-) clutch 'open' */
    void set_K_O_B(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Best. (Transducer overbridge.-) clutch 'open' */
    bool get_K_O_B() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Best. (Transducer overbridge.-) clutch 'closed' */
    void set_K_G_B(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets Best. (Transducer overbridge.-) clutch 'closed' */
    bool get_K_G_B() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets terrain */
    void set_G_G(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets terrain */
    bool get_G_G() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets Basic switch program O.K. */
    void set_GSP_OK(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets Basic switch program O.K. */
    bool get_GSP_OK() const { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets driving resistance high */
    void set_FW_HOCH(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets driving resistance high */
    bool get_FW_HOCH() const { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets circuit */
    void set_SCHALT(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets circuit */
    bool get_SCHALT() const { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets hand switching mode */
    void set_HSM(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets hand switching mode */
    bool get_HSM() const { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets Ball start */
    void set_KS(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Ball start */
    bool get_KS() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets EVALUTION */
    void set_ALF(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets EVALUTION */
    bool get_ALF() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Gearstrug. emergency */
    void set_GS_NOTL(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets Gearstrug. emergency */
    bool get_GS_NOTL() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets Overtemperature gearbox */
    void set_UEHITZ_GET(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets Overtemperature gearbox */
    bool get_UEHITZ_GET() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Driving program for AAD */
    void set_FPC_AAD_NEU(GS_218h_FPC_AAD_NEU value){ raw = (raw & 0xfffffffff8ffffff) | ((uint64_t)value & 0x7) << 24; }

    /** Gets Driving program for AAD */
    GS_218h_FPC_AAD_NEU get_FPC_AAD_NEU() const { return (GS_218h_FPC_AAD_NEU)(raw >> 24 & 0x7); }
        
    /** Sets Motor Moment Request Parity (straight parity) */
    void set_MPAR_EGS(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets Motor Moment Request Parity (straight parity) */
    bool get_MPAR_EGS() const { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets engagement mode / drive torque control */
    void set_DYN1_EGS(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets engagement mode / drive torque control */
    bool get_DYN1_EGS() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets engagement mode / drive torque control */
    void set_DYN0_AMR_EGS(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets engagement mode / drive torque control */
    bool get_DYN0_AMR_EGS() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets Convertible bridging clutch load-free */
    void set_K_LSTFR(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Convertible bridging clutch load-free */
    bool get_K_LSTFR() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets Return mode transmission control */
    void set_RS_Md_GS(GS_218h_RS_Md_GS value){ raw = (raw & 0xfffffffffffcffff) | ((uint64_t)value & 0x3) << 16; }

    /** Gets Return mode transmission control */
    GS_218h_RS_Md_GS get_RS_Md_GS() const { return (GS_218h_RS_Md_GS)(raw >> 16 & 0x3); }
        
    /** Sets Creep torque (FFH at EGS, CVT) or Calid / CVN */
    void set_MKRIECH(GS_218h_MKRIECH value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets Creep torque (FFH at EGS, CVT) or Calid / CVN */
    GS_218h_MKRIECH get_MKRIECH() const { return (GS_218h_MKRIECH)(raw >> 8 & 0xff); }
        
    /** Sets status error check */
    void set_FEHLPRF_ST(GS_218h_FEHLPRF_ST value){ raw = (raw & 0xffffffffffffff3f) | ((uint64_t)value & 0x3) << 6; }

    /** Gets status error check */
    GS_218h_FEHLPRF_ST get_FEHLPRF_ST() const { return (GS_218h_FEHLPRF_ST)(raw >> 6 & 0x3); }
        
    /** Sets CALID / CVN transmission active */
    void set_CALID_CVN_AKT(bool value){ raw = (raw & 0xffffffffffffffdf) | ((uint64_t)value & 0x1) << 5; }

    /** Gets CALID / CVN transmission active */
    bool get_CALID_CVN_AKT() const { return (bool)(raw >> 5 & 0x1); }
        
    /** Sets error number or counter for calid / CVN transmission. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_FEHLER(uint8_t value){ raw = (raw & 0xffffffffffffffe0) | ((uint64_t)value & 0x1f) << 0; }

    /** Gets error number or counter for calid / CVN transmission. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_FEHLER() const { return (uint8_t)(raw >> 0 & 0x1f); }
        
} GS_218;



class ECU_GS {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case TCM_A2_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case SBW_ANZ_GS_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case SBW_23A_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case GS_418_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case GS_338_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case GS_218_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to TCM_A2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_TCM_A2(uint64_t now, uint64_t max_expire_time, TCM_A2* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to SBW_ANZ_GS
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SBW_ANZ_GS(uint64_t now, uint64_t max_expire_time, SBW_ANZ_GS* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to SBW_23A
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SBW_23A(uint64_t now, uint64_t max_expire_time, SBW_23A* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to GS_418
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GS_418(uint64_t now, uint64_t max_expire_time, GS_418* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
        /** Sets data in pointer to GS_338
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GS_338(uint64_t now, uint64_t max_expire_time, GS_338* dest) const {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[4] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[4];
                return true;
            }
        }
            
        /** Sets data in pointer to GS_218
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GS_218(uint64_t now, uint64_t max_expire_time, GS_218* dest) const {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[5] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[5];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[6];
		uint64_t LAST_FRAME_TIMES[6];
};
#endif // __ECU_GS_H_

#endif // EGS_SPRINTER_MODE