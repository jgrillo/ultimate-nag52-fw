
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'BSM_M'
*/

#ifdef EGS_SPRINTER_MODE

#ifndef __ECU_BSM_M_H_
#define __ECU_BSM_M_H_

#include <stdint.h>
    
#define BSM_WARN_RQ_CAN_ID 0x017E

/** E: unknown */
enum class BSM_WARN_RQ_BSM_ActvLmp_Rt_Brt {
	SNV = 255, // S: BSM brightness active lamp right
};

/** E: unknown */
enum class BSM_WARN_RQ_BSM_WarnLmp_Lt_Brt {
	SNV = 255, // S: BSM brightness warning lamp link
};

/** E: unknown */
enum class BSM_WARN_RQ_BSM_WarnLmp_Rt_Brt {
	SNV = 255, // S: BSM brightness warning lamp right
};

/** E: unknown */
enum class BSM_WARN_RQ_BSM_MsgDisp_Rq {
	IDLE = 0, // S: Request BSM message
	MSG1 = 1, // unknown
	MSG2 = 2, // unknown
	MSG3 = 3, // unknown
	SNA = 7, // unknown
};

/** E: unknown */
enum class BSM_WARN_RQ_BSM_AcustcWarn_Rq {
	IDLE = 0, // S: ACTUSTIC WARNING BSM
	CONT = 1, // unknown
	SNA = 3, // unknown
};

/** E: unknown */
enum class BSM_WARN_RQ_BSM_Md_Rq_Ack {
	OFF = 0, // S: Confirmation requirement BSM mode
	ACTIVE = 1, // unknown
	FLT_NA = 2, // unknown
	FLT_RADAR_OFF = 3, // unknown
	SNA = 7, // unknown
};

/** E: unknown */
enum class BSM_WARN_RQ_BSM_Master_Obj_Trans {
	NOOBJ = 0, // S: object handover
	OBJ1 = 1, // unknown
	OBJ2 = 2, // unknown
};

/** E: unknown */
enum class BSM_WARN_RQ_DTR_Beep_Rq_Src {
	DTR = 0, // S: Source of the requirement DTR Warnington
	CMS = 1, // unknown
	APG = 2, // unknown
	BSM = 3, // unknown
	SNA = 7, // unknown
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of BSM_WARN_RQ */
	uint32_t get_canid(){ return BSM_WARN_RQ_CAN_ID; }
    /** Sets BSM brightness active lamp left */
    void set_BSM_ActvLmp_Lt_Brt( value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets BSM brightness active lamp left */
     get_BSM_ActvLmp_Lt_Brt() const { return ()(raw >> 56 & 0xff); }
        
    /** Sets E: unknown */
    void set_BSM_ActvLmp_Rt_Brt(BSM_WARN_RQ_BSM_ActvLmp_Rt_Brt value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets E: unknown */
    BSM_WARN_RQ_BSM_ActvLmp_Rt_Brt get_BSM_ActvLmp_Rt_Brt() const { return (BSM_WARN_RQ_BSM_ActvLmp_Rt_Brt)(raw >> 48 & 0xff); }
        
    /** Sets E: unknown */
    void set_BSM_WarnLmp_Lt_Brt(BSM_WARN_RQ_BSM_WarnLmp_Lt_Brt value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets E: unknown */
    BSM_WARN_RQ_BSM_WarnLmp_Lt_Brt get_BSM_WarnLmp_Lt_Brt() const { return (BSM_WARN_RQ_BSM_WarnLmp_Lt_Brt)(raw >> 40 & 0xff); }
        
    /** Sets E: unknown */
    void set_BSM_WarnLmp_Rt_Brt(BSM_WARN_RQ_BSM_WarnLmp_Rt_Brt value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets E: unknown */
    BSM_WARN_RQ_BSM_WarnLmp_Rt_Brt get_BSM_WarnLmp_Rt_Brt() const { return (BSM_WARN_RQ_BSM_WarnLmp_Rt_Brt)(raw >> 32 & 0xff); }
        
    /** Sets E: unknown */
    void set_BSM_MsgDisp_Rq(BSM_WARN_RQ_BSM_MsgDisp_Rq value){ raw = (raw & 0xffffffff8fffffff) | ((uint64_t)value & 0x7) << 28; }

    /** Gets E: unknown */
    BSM_WARN_RQ_BSM_MsgDisp_Rq get_BSM_MsgDisp_Rq() const { return (BSM_WARN_RQ_BSM_MsgDisp_Rq)(raw >> 28 & 0x7); }
        
    /** Sets E: unknown */
    void set_BSM_AcustcWarn_Rq(BSM_WARN_RQ_BSM_AcustcWarn_Rq value){ raw = (raw & 0xffffffffff3fffff) | ((uint64_t)value & 0x3) << 22; }

    /** Gets E: unknown */
    BSM_WARN_RQ_BSM_AcustcWarn_Rq get_BSM_AcustcWarn_Rq() const { return (BSM_WARN_RQ_BSM_AcustcWarn_Rq)(raw >> 22 & 0x3); }
        
    /** Sets E: unknown */
    void set_BSM_Md_Rq_Ack(BSM_WARN_RQ_BSM_Md_Rq_Ack value){ raw = (raw & 0xffffffffffc7ffff) | ((uint64_t)value & 0x7) << 19; }

    /** Gets E: unknown */
    BSM_WARN_RQ_BSM_Md_Rq_Ack get_BSM_Md_Rq_Ack() const { return (BSM_WARN_RQ_BSM_Md_Rq_Ack)(raw >> 19 & 0x7); }
        
    /** Sets E: unknown */
    void set_BSM_Master_Obj_Trans(BSM_WARN_RQ_BSM_Master_Obj_Trans value){ raw = (raw & 0xffffffffffffff3f) | ((uint64_t)value & 0x3) << 6; }

    /** Gets E: unknown */
    BSM_WARN_RQ_BSM_Master_Obj_Trans get_BSM_Master_Obj_Trans() const { return (BSM_WARN_RQ_BSM_Master_Obj_Trans)(raw >> 6 & 0x3); }
        
    /** Sets E: unknown */
    void set_DTR_Beep_Rq_Src(BSM_WARN_RQ_DTR_Beep_Rq_Src value){ raw = (raw & 0xfffffffffffffff8) | ((uint64_t)value & 0x7) << 0; }

    /** Gets E: unknown */
    BSM_WARN_RQ_DTR_Beep_Rq_Src get_DTR_Beep_Rq_Src() const { return (BSM_WARN_RQ_DTR_Beep_Rq_Src)(raw >> 0 & 0x7); }
        
} BSM_WARN_RQ;



class ECU_BSM_M {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case BSM_WARN_RQ_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to BSM_WARN_RQ
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BSM_WARN_RQ(uint64_t now, uint64_t max_expire_time, BSM_WARN_RQ* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[1];
		uint64_t LAST_FRAME_TIMES[1];
};
#endif // __ECU_BSM_M_H_

#endif // EGS_SPRINTER_MODE