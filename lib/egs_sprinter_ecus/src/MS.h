
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'MS'
*/

#ifdef EGS_SPRINTER_MODE

#ifndef __ECU_MS_H_
#define __ECU_MS_H_

#include <stdint.h>
    
#define TC_EBBC_DISP_RQ_CAN_ID 0x0249
#define TC_DISP_RQ_CAN_ID 0x034F
#define SG_A1_ECM_CAN_ID 0x02F7
#define NM_ECM_CAN_ID 0x06CE
#define MS_OBD_3D0_CAN_ID 0x03D0
#define MS_ANZ_CAN_ID 0x033D
#define MS_608_CAN_ID 0x0608
#define MS_312_CAN_ID 0x0312
#define MS_308_CAN_ID 0x0308
#define MS_2F3_CAN_ID 0x02F3
#define MS_268_CAN_ID 0x0268
#define MS_212_CAN_ID 0x0212
#define MS_210_CAN_ID 0x0210
#define CNG_ANZ_CAN_ID 0x0326
#define ADBLUE_DISP_RQ_CAN_ID 0x02A2
#define AAD_580_CAN_ID 0x0580

/** Trip Computer: Energy Balance Bar Chart Display Counter of Data Set # 1 */
enum class TC_EBBC_DISP_RQ_TC_EBBC_DispCnt1 {
	SNV = 63, // unknown
};

/** Trip Computer: Energy Balance Bar Chart Average Fuel Consumption of Data Set # 1 */
enum class TC_EBBC_DISP_RQ_TC_EBBC_AvgFuelCons1 {
	SNV = 255, // unknown
};

/** Trip Computer: Energy Balance Bar Chart Average Recuperation Level of Data Set # 1 */
enum class TC_EBBC_DISP_RQ_TC_EBBC_AvgRecupLvl1 {
	SNV = 255, // unknown
};

/** Trip Computer: Energy Balance Bar Chart Display Counter of Data Set # 2 */
enum class TC_EBBC_DISP_RQ_TC_EBBC_DispCnt2 {
	SNV = 63, // unknown
};

/** Trip Computer: Energy Balance Bar Chart Average Fuel Consumption of Data Set # 2 */
enum class TC_EBBC_DISP_RQ_TC_EBBC_AvgFuelCons2 {
	SNV = 255, // unknown
};

/** Trip Computer: Energy Balance Bar Chart Average Recuperation Level of Data Set # 2 */
enum class TC_EBBC_DISP_RQ_TC_EBBC_AvgRecupLvl2 {
	SNV = 255, // unknown
};

/** Trip Computer: Energy Balance Bar Chart Display Index */
enum class TC_EBBC_DISP_RQ_TC_EBBC_DispIdx {
	SNV = 63, // unknown
};

/** Trip Computer: Energy Balance Bar Chart Actual Or Overall Avgerage Fuel Consumption */
enum class TC_EBBC_DISP_RQ_TC_EBBC_FuelCons {
	SNV = 255, // unknown
};

/** TC_FUELTYPE_TC_DISP_RQ */
enum class TC_DISP_RQ_TC_FuelType_TC_DISP_RQ {
	GASEOUS = 0, // unknown
	LIQUID = 1, // unknown
	NDEF2 = 2, // unknown
	SNA = 3, // unknown
};

/** Trip Computer: Gasous Fuel Consumption from start */
enum class TC_DISP_RQ_TC_GasFuelCons_Start {
	SNV = 255, // unknown
};

/** Trip Computer: Gasous Fuel Consumption from Reset */
enum class TC_DISP_RQ_TC_GasFuelCons_Reset {
	SNV = 255, // unknown
};

/** Trip Computer: Actual Gasous Fuel Consumption */
enum class TC_DISP_RQ_TC_GasFuelCons {
	SNV = 255, // unknown
};

/** Trip Computer: Liquid Fuel Tank Range */
enum class TC_DISP_RQ_TC_GasFuelTankRng {
	SNV = 255, // unknown
};

/** Starter / Generator Output DC Current */
enum class SG_A1_ECM_SG_OutDC_Curr_ECM {
	SNV = 255, // unknown
};

/** Starter / Generator Output DC Voltage */
enum class SG_A1_ECM_SG_OutDC_Volt_ECM {
	SNV = 255, // unknown
};

/** Generator Excitation Current */
enum class SG_A1_ECM_PN14_GenExctCurr {
	SNV = 255, // unknown
};

/** Generator Style */
enum class SG_A1_ECM_PN14_GenStyle {
	XS = 0, // unknown
	S = 1, // unknown
	M = 2, // unknown
	L = 3, // unknown
	XL1 = 4, // unknown
	XL2 = 5, // unknown
	XXL = 6, // unknown
	XL3 = 7, // unknown
	RSG = 8, // unknown
	SNA = 15, // unknown
};

/** Generator Supplier */
enum class SG_A1_ECM_PN14_GenSupplr {
	BOSCH = 0, // unknown
	VALEO = 1, // unknown
	DELPHI = 2, // unknown
	HITACHI = 3, // unknown
	DENSO = 4, // unknown
	MELCO = 5, // unknown
	VISTEON = 6, // unknown
	SNA = 7, // unknown
};

/** Network Management Fashion */
enum class NM_ECM_NM_Mode {
	LHOM = 252, // unknown
	RING = 253, // unknown
	ALIVE = 254, // unknown
	SNA = 255, // unknown
};

/** Network Management Logical Successor */
enum class NM_ECM_NM_Successor {
	SNV = 255, // unknown
};

/** Network Management UserData Launch Type */
enum class NM_ECM_NM_Ud_Launch {
	BROADCAST = 4, // unknown
	SNA = 63, // unknown
};

/** Network Management UserData Service No. */
enum class NM_ECM_NM_Ud_Srv {
	DATA_OK_BC = 1, // unknown
	WAKEUP_SA = 2, // unknown
	SBC_STAT_BC = 5, // unknown
	AWAKE_BC = 15, // unknown
	SNA = 255, // unknown
};

/** Network Identification */
enum class NM_ECM_Nw_Id {
	BACKBONE = 4, // unknown
	DIAGNOSTICS = 5, // unknown
	BODY = 6, // unknown
	CHASSIS = 7, // unknown
	POWERTRAIN = 8, // unknown
	PT_SENSOR = 9, // unknown
	DYNAMICS = 11, // unknown
	HEADUNIT = 14, // unknown
	IMPACT = 15, // unknown
	SNA = 255, // unknown
};

/** Conditions for Ignition Cycle Counter (RBM) State */
enum class MS_OBD_3D0h_OBD_IgnCycCntCond_Stat {
	INACT = 0, // unknown
	ACTV = 1, // unknown
	FLT = 2, // unknown
	NDEF3 = 3, // unknown
};

/** Conditions for General Denominator (RBM) State */
enum class MS_OBD_3D0h_OBD_GnrlDenCond_Stat {
	INACT = 0, // unknown
	ACTV = 1, // unknown
	FLT = 2, // unknown
	NDEF3 = 3, // unknown
};

/** Number of the ASS warning message */
enum class MS_ANZ_ASS_WARN {
	IDLE = 0, // unknown
	M1 = 1, // unknown
	M2 = 2, // unknown
	M3 = 3, // unknown
	M4 = 4, // unknown
	M5 = 5, // unknown
	M6 = 6, // unknown
	M7 = 7, // unknown
	M8 = 8, // unknown
	M9 = 9, // unknown
	M10 = 10, // unknown
	M11 = 11, // unknown
	M12 = 12, // unknown
	M13 = 13, // unknown
	M14 = 14, // unknown
	M15 = 15, // unknown
};

/** Number of the ASS status message */
enum class MS_ANZ_ASS_DSPL {
	IDLE = 0, // unknown
	M1 = 1, // unknown
	M2 = 2, // unknown
	M3 = 3, // unknown
	M4 = 4, // unknown
	M5 = 5, // unknown
	M6 = 6, // unknown
	M7 = 7, // unknown
	M8 = 8, // unknown
	M9 = 9, // unknown
	M10 = 10, // unknown
	M11 = 11, // unknown
	M12 = 12, // unknown
	M13 = 13, // unknown
	M14 = 14, // unknown
	M15 = 15, // unknown
};

/** engine coolant temperature */
enum class MS_608h_T_MOT {
	IDLE = 0, // unknown
	CONT = 1, // unknown
	SNA = 3, // unknown
};

/** intake air temperature */
enum class MS_608h_T_LUFT {
	DTR = 0, // unknown
	CMS = 1, // unknown
	APG = 2, // unknown
	BSM = 3, // unknown
	SNA = 7, // unknown
};

/** Vehicle code body */
enum class MS_608h_FCOD_KAR {
};

/** Vehicle code series */
enum class MS_608h_FCOD_BR {
	NOOBJ = 0, // unknown
	OBJ1 = 1, // unknown
	OBJ2 = 2, // unknown
};

/** FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) */
enum class MS_608h_FCOD_MOT {
	M272E35 = 0, // unknown
	M271E18ML105 = 1, // unknown
	M271E18ML120 = 2, // unknown
	M112E37 = 3, // unknown
	M272E25 = 4, // unknown
	M272E30 = 5, // unknown
	PM2320_01 = 6, // unknown
	PM2320_02 = 7, // unknown
	M112E32 = 8, // unknown
	M273E46 = 10, // unknown
	M273E55 = 11, // unknown
	M112E26 = 12, // unknown
	M113E43 = 13, // unknown
	M113E50 = 14, // unknown
	M271E18ML135_140 = 18, // unknown
	M271DE18ML105 = 19, // unknown
	M271DE18ML125 = 20, // unknown
	M111E_E23ML = 22, // unknown
	M111E_E20 = 23, // unknown
	M111E_E20ML = 24, // unknown
	M112E32_140 = 25, // unknown
	M266E20ATL = 26, // unknown
	M266E15 = 27, // unknown
	M266E17 = 28, // unknown
	M266E20 = 29, // unknown
	M275E55 = 30, // unknown
	M137E58 = 31, // unknown
	OM640DE20LA60 = 32, // unknown
	OM640DE20LA80 = 34, // unknown
	OM642DE30LA155_165 = 35, // unknown
	OM640DE20LA100 = 36, // unknown
	OM613DE32LA = 37, // unknown
	OM639DE15LA = 38, // unknown
	OM628DE40LA = 39, // unknown
};

/** Fixed maximum speed */
enum class MS_608h_V_MAX_FIX {
	SNV = 255, // unknown
};

/** consumption */
enum class MS_608h_VB {
	SNV = 255, // unknown
};

/** particle filter warning */
enum class MS_608h_PFW {
	OK = 0, // unknown
	PFW1 = 1, // unknown
	PFW2 = 2, // unknown
	SNV = 3, // unknown
};

/** Particle Filter Correction Offset FMMOTMAX */
enum class MS_608h_PFKO {
	SNV = 15, // unknown
};

/** Motor torque static */
enum class MS_312h_M_STA {
	SNV = 255, // unknown
};

/** Motor Torque Maximum incl. DYN.Turbocharger */
enum class MS_312h_M_MAX_ATL {
	SNV = 255, // unknown
};

/** Motor torque maximum */
enum class MS_312h_M_MAX {
	IDLE = 0, // unknown
	MSG1 = 1, // unknown
	MSG2 = 2, // unknown
	MSG3 = 3, // unknown
	SNA = 7, // unknown
};

/** Motor torque minimal */
enum class MS_312h_M_MIN_SCHUB {
	OFF = 0, // unknown
	ACTIVE = 1, // unknown
	FLT_NA = 2, // unknown
	FLT_RADAR_OFF = 3, // unknown
	SNA = 7, // unknown
};

/** engine speed */
enum class MS_308h_NMOT {
	NOOBJ = 0, // unknown
	OBJ1 = 1, // unknown
	OBJ2 = 2, // unknown
};

/** Oil temperature */
enum class MS_308h_T_OEL {
	OK = 0, // unknown
	BSM_PERM = 1, // unknown
	BSM_TEMP = 2, // unknown
	SNA = 7, // unknown
};

/** oil level */
enum class MS_308h_OEL_FS {
	SNV = 255, // unknown
};

/** oil quality */
enum class MS_308h_OEL_QUAL {
	SNV = 255, // unknown
};

/** Engine Running State */
enum class MS_2F3h_EngRun_Stat {
	STOP = 0, // unknown
	START = 1, // unknown
	IDLE_UNSTBL = 2, // unknown
	IDLE_STBL = 3, // unknown
	UNLIMITED = 4, // unknown
	LIMITED = 5, // unknown
	NDEF6 = 6, // unknown
	SNA = 7, // unknown
};

/** Transmission Driving Position Display Request */
enum class MS_2F3h_TxDrvPosn_Disp_Rq {
	N = 0, // unknown
	D1 = 1, // unknown
	D2 = 2, // unknown
	D3 = 3, // unknown
	D4 = 4, // unknown
	D5 = 5, // unknown
	D6 = 6, // unknown
	D7 = 7, // unknown
	D8 = 8, // unknown
	D9 = 9, // unknown
	R = 11, // unknown
	P = 13, // unknown
	PWRFREE = 14, // unknown
	SNA = 15, // unknown
};

/** Proposed Target Gear */
enum class MS_2F3h_Gr_Target_Prop_Disp_Rq {
	SNV = 255, // unknown
};

/** Eco LED on Request */
enum class MS_2F3h_ECO_LED_On_Rq {
	UPSTOP = 0, // unknown
	PSD = 1, // unknown
	NDEF2 = 2, // unknown
};

/** Actual Engine Idle Speed Level */
enum class MS_2F3h_EngIdleRPMLevel_Act {
	AUS = 0, // unknown
	EIN = 1, // unknown
	NDEF2 = 2, // unknown
	SNA = 3, // unknown
};

/** target translation, lower border (FCVT) */
enum class MS_268h_IMIN_MS {
	OK = 0, // unknown
	ESP_DEF = 1, // unknown
	ESP_OFF = 2, // unknown
	DIFF_GEARLOCK_SEL = 3, // unknown
	DIFF_GEARLOCK_AKT = 8, // unknown
	AAS_ESP_DEF = 9, // unknown
	AAS_ASR_ESP_DEF = 10, // unknown
	ASR_ESP_DEF = 12, // unknown
	AAS_ASR_BAS_ESP_DEF = 13, // unknown
	ALL_DEF = 16, // unknown
	ALL_DEF_GBV = 17, // unknown
	ALL_DIAG_GBV = 20, // unknown
	AAS_DEF = 28, // unknown
	SNV = 31, // unknown
};

/** Target Translation, Upper Border (FCVT) */
enum class MS_268h_IMAX_MS {
	AYLOW = 1, // unknown
	AYHIGH = 2, // unknown
	SNV = 3, // unknown
};

/** Status heating power */
enum class MS_268h_HZL_ST {
	SNV = 255, // unknown
};

/** Generator utilization (LIN generators only!) */
enum class MS_268h_LAST_GEN {
	SNV = 255, // unknown
};

/** Max. Climate compressor torque (only 169) */
enum class MS_268h_M_KOMP_MAX {
	SNV = 255, // unknown
};

/** pedal value driver */
enum class MS_268h_PW_F {
	SNV = 63, // unknown
};

/** Target voltage specification generator */
enum class MS_268h_ALT_OUTDC_V_ECM {
	SNV = 255, // unknown
};

/** Maximum controller current specification generator */
enum class MS_268h_ALT_EXCCURR_ECM {
	SNV = 255, // unknown
};

/** Motorle-rolling speed */
enum class MS_212h_NMOTS {
	SNV = 255, // unknown
};

/** default torque driver */
enum class MS_212h_M_FV {
	SNV = 255, // unknown
};

/** replacement feed torque driver */
enum class MS_212h_M_FEV {
	SNV = 255, // unknown
};

/** Property torque ESP incl. Shear content */
enum class MS_212h_M_ESPV_SCHUB {
	OK = 0, // unknown
	USPGF = 1, // unknown
	SNV = 7, // unknown
};

/** Switching shift MS */
enum class MS_210h_SLV_MS {
	EIN = 0, // unknown
	WARN = 1, // unknown
	AUS = 2, // unknown
	INIT = 3, // unknown
	PRW_NV = 6, // unknown
	SNV = 7, // unknown
};

/** Sprocket, upper limit */
enum class MS_210h_GMAX_MS {
	BREMSE_NEIN = 0, // unknown
	BREMSE_JA = 1, // unknown
	SNV = 3, // unknown
};

/** Sprocket, lower limit */
enum class MS_210h_GMIN_MS {
	OK = 0, // unknown
	WARN_OHNE = 1, // unknown
	PRW_NV = 2, // unknown
	NEU_AKT = 3, // unknown
	WARN_VL = 4, // unknown
	WARN_VR = 5, // unknown
	WARN_HL = 6, // unknown
	WARN_HR = 7, // unknown
	SNV = 15, // unknown
};

/** pedal value */
enum class MS_210h_PW {
	T20_0 = 1, // unknown
	T23_1 = 2, // unknown
	SNV = 3, // unknown
};

/** factor for departure. d. Max. Mom. At Aufneh. A.Print */
enum class MS_210h_FMMOTMAX {
	SNV = 255, // unknown
};

/** set maximum or cruise speed */
enum class MS_210h_V_MAX_TM {
	SNV = 255, // unknown
};

/** Tank level natural gas */
enum class CNG_ANZ_TANK_FS_GAS {
	SNV = 255, // unknown
};

/** high pressure CNG */
enum class CNG_ANZ_P_CNG {
	SNV = 255, // unknown
};

/** AdBlue Remaining Distance */
enum class ADBLUE_DISP_RQ_Adblue_RemainDist {
	ANF_N = 1, // unknown
	IDLE = 2, // unknown
	SNV = 3, // unknown
};

/** AdBlue Reserve Marker of AdBlue Fuel Level */
enum class ADBLUE_DISP_RQ_AdBlue_ResMrk_Disp {
	PASSIV = 0, // unknown
	VOR = 1, // unknown
	RUECK = 2, // unknown
	SNV = 3, // unknown
};

/** View Text in Instrument Cluster of the Possible Values */
enum class ADBLUE_DISP_RQ_AdBlue_MenueTxt_Disp {
	SNV = 255, // unknown
};

/** AdBlue (EU6) Check Message Display Request */
enum class ADBLUE_DISP_RQ_AdblueEU6_ChkMsg_Disp_Rq_V2 {
	SNV = 255, // unknown
};

/** AdBlue (EU6) Refill Message Display Request */
enum class ADBLUE_DISP_RQ_AdblueEU6_RefillMsg_Disp_Rq_V2 {
	PASSIV = 0, // unknown
	VOR = 1, // unknown
	RUECK = 2, // unknown
	SNV = 3, // unknown
};

/** Remaining Distance Until 'No Restart' (EU6) */
enum class ADBLUE_DISP_RQ_AdblueEU6_RemainDist {
	SNV = 255, // unknown
};

/** Level AdBlue Tank */
enum class ADBLUE_DISP_RQ_AdBlue_TankLvl_Disp_Rq {
	IDLE = 0, // unknown
	DSR_RDY = 1, // unknown
	NDEF2 = 2, // unknown
	DSR_ON = 3, // unknown
};

/** Range AdBlue tank for the service display */
enum class ADBLUE_DISP_RQ_Adblue_RemainDistSrvce_Disp {
	SNV = 255, // unknown
};

/** indicator acceleration type (> 100: dynamic) */
enum class AAD_580h_FTK_BMI {
	PASSIV = 0, // unknown
	VOR = 1, // unknown
	RUECK = 2, // unknown
	SNV = 3, // unknown
};

/** code number of transverse acceleration type (> 100: dynamic) */
enum class AAD_580h_FTK_LMI {
	PASSIV = 0, // unknown
	G1 = 1, // unknown
	G2 = 2, // unknown
	G3 = 3, // unknown
	G4 = 4, // unknown
	G5 = 5, // unknown
	G6 = 6, // unknown
	G7 = 7, // unknown
};

/** code number brake type (> 100: dynamic) */
enum class AAD_580h_FTK_VMI {
	PASSIV = 0, // unknown
	G1 = 1, // unknown
	G2 = 2, // unknown
	G3 = 3, // unknown
	G4 = 4, // unknown
	G5 = 5, // unknown
	G6 = 6, // unknown
	G7 = 7, // unknown
};

/** Max. Diff.Pedal angle value per maneuver */
enum class AAD_580h_FTK_DPW {
	SKL0 = 0, // unknown
	SKL1 = 1, // unknown
	SKL2 = 2, // unknown
	SKL3 = 3, // unknown
	SKL4 = 4, // unknown
	SKL5 = 5, // unknown
	SKL6 = 6, // unknown
	SKL7 = 7, // unknown
	SKL8 = 8, // unknown
	SKL9 = 9, // unknown
	SKL10 = 10, // unknown
	SKL11 = 11, // unknown
	SKL12 = 12, // unknown
	SKL13 = 13, // unknown
	SKL14 = 14, // unknown
	SKL15 = 15, // unknown
};

/** Continuous driver watching */
enum class AAD_580h_AADKB {
	ERR_DIAG = 0, // unknown
	NORM = 1, // unknown
	N_DEF = 2, // unknown
	ABGAS = 3, // unknown
};

/** nervousness */
enum class AAD_580h_AADNT {
	SNV = 255, // unknown
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of TC_EBBC_DISP_RQ */
	uint32_t get_canid(){ return TC_EBBC_DISP_RQ_CAN_ID; }
    /** Sets Trip Computer: Energy Balance Bar Chart Display Counter of Data Set # 1 */
    void set_TC_EBBC_DispCnt1(TC_EBBC_DISP_RQ_TC_EBBC_DispCnt1 value){ raw = (raw & 0x03ffffffffffffff) | ((uint64_t)value & 0x3f) << 58; }

    /** Gets Trip Computer: Energy Balance Bar Chart Display Counter of Data Set # 1 */
    TC_EBBC_DISP_RQ_TC_EBBC_DispCnt1 get_TC_EBBC_DispCnt1() const { return (TC_EBBC_DISP_RQ_TC_EBBC_DispCnt1)(raw >> 58 & 0x3f); }
        
    /** Sets Trip Computer: Energy Balance Bar Chart Average Fuel Consumption of Data Set # 1 */
    void set_TC_EBBC_AvgFuelCons1(TC_EBBC_DISP_RQ_TC_EBBC_AvgFuelCons1 value){ raw = (raw & 0xfc00ffffffffffff) | ((uint64_t)value & 0x3ff) << 48; }

    /** Gets Trip Computer: Energy Balance Bar Chart Average Fuel Consumption of Data Set # 1 */
    TC_EBBC_DISP_RQ_TC_EBBC_AvgFuelCons1 get_TC_EBBC_AvgFuelCons1() const { return (TC_EBBC_DISP_RQ_TC_EBBC_AvgFuelCons1)(raw >> 48 & 0x3ff); }
        
    /** Sets Trip Computer: Energy Balance Bar Chart Average Recuperation Level of Data Set # 1 */
    void set_TC_EBBC_AvgRecupLvl1(TC_EBBC_DISP_RQ_TC_EBBC_AvgRecupLvl1 value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Trip Computer: Energy Balance Bar Chart Average Recuperation Level of Data Set # 1 */
    TC_EBBC_DISP_RQ_TC_EBBC_AvgRecupLvl1 get_TC_EBBC_AvgRecupLvl1() const { return (TC_EBBC_DISP_RQ_TC_EBBC_AvgRecupLvl1)(raw >> 40 & 0xff); }
        
    /** Sets Trip Computer: Energy Balance Bar Chart Display Counter of Data Set # 2 */
    void set_TC_EBBC_DispCnt2(TC_EBBC_DISP_RQ_TC_EBBC_DispCnt2 value){ raw = (raw & 0xffffff03ffffffff) | ((uint64_t)value & 0x3f) << 34; }

    /** Gets Trip Computer: Energy Balance Bar Chart Display Counter of Data Set # 2 */
    TC_EBBC_DISP_RQ_TC_EBBC_DispCnt2 get_TC_EBBC_DispCnt2() const { return (TC_EBBC_DISP_RQ_TC_EBBC_DispCnt2)(raw >> 34 & 0x3f); }
        
    /** Sets Trip Computer: Energy Balance Bar Chart Average Fuel Consumption of Data Set # 2 */
    void set_TC_EBBC_AvgFuelCons2(TC_EBBC_DISP_RQ_TC_EBBC_AvgFuelCons2 value){ raw = (raw & 0xfffffffc00ffffff) | ((uint64_t)value & 0x3ff) << 24; }

    /** Gets Trip Computer: Energy Balance Bar Chart Average Fuel Consumption of Data Set # 2 */
    TC_EBBC_DISP_RQ_TC_EBBC_AvgFuelCons2 get_TC_EBBC_AvgFuelCons2() const { return (TC_EBBC_DISP_RQ_TC_EBBC_AvgFuelCons2)(raw >> 24 & 0x3ff); }
        
    /** Sets Trip Computer: Energy Balance Bar Chart Average Recuperation Level of Data Set # 2 */
    void set_TC_EBBC_AvgRecupLvl2(TC_EBBC_DISP_RQ_TC_EBBC_AvgRecupLvl2 value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Trip Computer: Energy Balance Bar Chart Average Recuperation Level of Data Set # 2 */
    TC_EBBC_DISP_RQ_TC_EBBC_AvgRecupLvl2 get_TC_EBBC_AvgRecupLvl2() const { return (TC_EBBC_DISP_RQ_TC_EBBC_AvgRecupLvl2)(raw >> 16 & 0xff); }
        
    /** Sets Trip Computer: Energy Balance Bar Chart Display Index */
    void set_TC_EBBC_DispIdx(TC_EBBC_DISP_RQ_TC_EBBC_DispIdx value){ raw = (raw & 0xffffffffffff03ff) | ((uint64_t)value & 0x3f) << 10; }

    /** Gets Trip Computer: Energy Balance Bar Chart Display Index */
    TC_EBBC_DISP_RQ_TC_EBBC_DispIdx get_TC_EBBC_DispIdx() const { return (TC_EBBC_DISP_RQ_TC_EBBC_DispIdx)(raw >> 10 & 0x3f); }
        
    /** Sets Trip Computer: Energy Balance Bar Chart Actual Or Overall Avgerage Fuel Consumption */
    void set_TC_EBBC_FuelCons(TC_EBBC_DISP_RQ_TC_EBBC_FuelCons value){ raw = (raw & 0xfffffffffffffc00) | ((uint64_t)value & 0x3ff) << 0; }

    /** Gets Trip Computer: Energy Balance Bar Chart Actual Or Overall Avgerage Fuel Consumption */
    TC_EBBC_DISP_RQ_TC_EBBC_FuelCons get_TC_EBBC_FuelCons() const { return (TC_EBBC_DISP_RQ_TC_EBBC_FuelCons)(raw >> 0 & 0x3ff); }
        
} TC_EBBC_DISP_RQ;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of TC_DISP_RQ */
	uint32_t get_canid(){ return TC_DISP_RQ_CAN_ID; }
    /** Sets TC_FUELTYPE_TC_DISP_RQ */
    void set_TC_FuelType_TC_DISP_RQ(TC_DISP_RQ_TC_FuelType_TC_DISP_RQ value){ raw = (raw & 0xcfffffffffffffff) | ((uint64_t)value & 0x3) << 60; }

    /** Gets TC_FUELTYPE_TC_DISP_RQ */
    TC_DISP_RQ_TC_FuelType_TC_DISP_RQ get_TC_FuelType_TC_DISP_RQ() const { return (TC_DISP_RQ_TC_FuelType_TC_DISP_RQ)(raw >> 60 & 0x3); }
        
    /** Sets Trip Computer: Gasous Fuel Consumption from start */
    void set_TC_GasFuelCons_Start(TC_DISP_RQ_TC_GasFuelCons_Start value){ raw = (raw & 0xfc00ffffffffffff) | ((uint64_t)value & 0x3ff) << 48; }

    /** Gets Trip Computer: Gasous Fuel Consumption from start */
    TC_DISP_RQ_TC_GasFuelCons_Start get_TC_GasFuelCons_Start() const { return (TC_DISP_RQ_TC_GasFuelCons_Start)(raw >> 48 & 0x3ff); }
        
    /** Sets Trip Computer: Gasous Fuel Consumption from Reset */
    void set_TC_GasFuelCons_Reset(TC_DISP_RQ_TC_GasFuelCons_Reset value){ raw = (raw & 0xfffffc00ffffffff) | ((uint64_t)value & 0x3ff) << 32; }

    /** Gets Trip Computer: Gasous Fuel Consumption from Reset */
    TC_DISP_RQ_TC_GasFuelCons_Reset get_TC_GasFuelCons_Reset() const { return (TC_DISP_RQ_TC_GasFuelCons_Reset)(raw >> 32 & 0x3ff); }
        
    /** Sets Trip Computer: Actual Gasous Fuel Consumption */
    void set_TC_GasFuelCons(TC_DISP_RQ_TC_GasFuelCons value){ raw = (raw & 0xfffffffffc00ffff) | ((uint64_t)value & 0x3ff) << 16; }

    /** Gets Trip Computer: Actual Gasous Fuel Consumption */
    TC_DISP_RQ_TC_GasFuelCons get_TC_GasFuelCons() const { return (TC_DISP_RQ_TC_GasFuelCons)(raw >> 16 & 0x3ff); }
        
    /** Sets Trip Computer: Gasoline Fuel Tank Level at 50% of Minimum */
    void set_TC_GasFuelTankLvl_Min_50(bool value){ raw = (raw & 0xfffffffffffff7ff) | ((uint64_t)value & 0x1) << 11; }

    /** Gets Trip Computer: Gasoline Fuel Tank Level at 50% of Minimum */
    bool get_TC_GasFuelTankLvl_Min_50() const { return (bool)(raw >> 11 & 0x1); }
        
    /** Sets Trip Computer: Liquid Fuel Tank Range */
    void set_TC_GasFuelTankRng(TC_DISP_RQ_TC_GasFuelTankRng value){ raw = (raw & 0xfffffffffffff800) | ((uint64_t)value & 0x7ff) << 0; }

    /** Gets Trip Computer: Liquid Fuel Tank Range */
    TC_DISP_RQ_TC_GasFuelTankRng get_TC_GasFuelTankRng() const { return (TC_DISP_RQ_TC_GasFuelTankRng)(raw >> 0 & 0x7ff); }
        
} TC_DISP_RQ;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SG_A1_ECM */
	uint32_t get_canid(){ return SG_A1_ECM_CAN_ID; }
    /** Sets Starter / Generator Output DC Current */
    void set_SG_OutDC_Curr_ECM(SG_A1_ECM_SG_OutDC_Curr_ECM value){ raw = (raw & 0x0000ffffffffffff) | ((uint64_t)value & 0xffff) << 48; }

    /** Gets Starter / Generator Output DC Current */
    SG_A1_ECM_SG_OutDC_Curr_ECM get_SG_OutDC_Curr_ECM() const { return (SG_A1_ECM_SG_OutDC_Curr_ECM)(raw >> 48 & 0xffff); }
        
    /** Sets Starter / Generator Output DC Voltage */
    void set_SG_OutDC_Volt_ECM(SG_A1_ECM_SG_OutDC_Volt_ECM value){ raw = (raw & 0xffff0000ffffffff) | ((uint64_t)value & 0xffff) << 32; }

    /** Gets Starter / Generator Output DC Voltage */
    SG_A1_ECM_SG_OutDC_Volt_ECM get_SG_OutDC_Volt_ECM() const { return (SG_A1_ECM_SG_OutDC_Volt_ECM)(raw >> 32 & 0xffff); }
        
    /** Sets Generator Excitation Current */
    void set_PN14_GenExctCurr(SG_A1_ECM_PN14_GenExctCurr value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Generator Excitation Current */
    SG_A1_ECM_PN14_GenExctCurr get_PN14_GenExctCurr() const { return (SG_A1_ECM_PN14_GenExctCurr)(raw >> 24 & 0xff); }
        
    /** Sets Generator Style */
    void set_PN14_GenStyle(SG_A1_ECM_PN14_GenStyle value){ raw = (raw & 0xffffffffff87ffff) | ((uint64_t)value & 0xf) << 19; }

    /** Gets Generator Style */
    SG_A1_ECM_PN14_GenStyle get_PN14_GenStyle() const { return (SG_A1_ECM_PN14_GenStyle)(raw >> 19 & 0xf); }
        
    /** Sets Generator Supplier */
    void set_PN14_GenSupplr(SG_A1_ECM_PN14_GenSupplr value){ raw = (raw & 0xfffffffffff8ffff) | ((uint64_t)value & 0x7) << 16; }

    /** Gets Generator Supplier */
    SG_A1_ECM_PN14_GenSupplr get_PN14_GenSupplr() const { return (SG_A1_ECM_PN14_GenSupplr)(raw >> 16 & 0x7); }
        
} SG_A1_ECM;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of NM_ECM */
	uint32_t get_canid(){ return NM_ECM_CAN_ID; }
    /** Sets Network Management Fashion */
    void set_NM_Mode(NM_ECM_NM_Mode value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Network Management Fashion */
    NM_ECM_NM_Mode get_NM_Mode() const { return (NM_ECM_NM_Mode)(raw >> 56 & 0xff); }
        
    /** Sets Network Management Logical Successor */
    void set_NM_Successor(NM_ECM_NM_Successor value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Network Management Logical Successor */
    NM_ECM_NM_Successor get_NM_Successor() const { return (NM_ECM_NM_Successor)(raw >> 48 & 0xff); }
        
    /** Sets Network Management Sleep Indication */
    void set_NM_Sleep_Ind(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Network Management Sleep Indication */
    bool get_NM_Sleep_Ind() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Network Management Sleep Acknowledge */
    void set_NM_Sleep_Ack(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Network Management Sleep Acknowledge */
    bool get_NM_Sleep_Ack() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Network Management UserData Launch Type */
    void set_NM_Ud_Launch(NM_ECM_NM_Ud_Launch value){ raw = (raw & 0xffffc0ffffffffff) | ((uint64_t)value & 0x3f) << 40; }

    /** Gets Network Management UserData Launch Type */
    NM_ECM_NM_Ud_Launch get_NM_Ud_Launch() const { return (NM_ECM_NM_Ud_Launch)(raw >> 40 & 0x3f); }
        
    /** Sets Network Management UserData Service No. */
    void set_NM_Ud_Srv(NM_ECM_NM_Ud_Srv value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets Network Management UserData Service No. */
    NM_ECM_NM_Ud_Srv get_NM_Ud_Srv() const { return (NM_ECM_NM_Ud_Srv)(raw >> 32 & 0xff); }
        
    /** Sets Stay Awake for CCP Measurement Active */
    void set_Awake_CCP_Actv(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Stay Awake for CCP Measurement Active */
    bool get_Awake_CCP_Actv() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Stay Awake for Engine Restart */
    void set_Awake_EngRestart(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Stay Awake for Engine Restart */
    bool get_Awake_EngRestart() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Stay Awake for Engine Fan Active */
    void set_Awake_EngFan_Actv(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets Stay Awake for Engine Fan Active */
    bool get_Awake_EngFan_Actv() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets Stay Awake for Afterrun Active */
    void set_Awake_Afterrun_Actv(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets Stay Awake for Afterrun Active */
    bool get_Awake_Afterrun_Actv() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Stay Awake for Ignition On */
    void set_Awake_Ignition_On(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Stay Awake for Ignition On */
    bool get_Awake_Ignition_On() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets Stay Awake for Diagnostics Active */
    void set_Awake_Diag_Actv(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets Stay Awake for Diagnostics Active */
    bool get_Awake_Diag_Actv() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets Stay Awake for Network Startup */
    void set_Awake_NwSt(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets Stay Awake for Network Startup */
    bool get_Awake_NwSt() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets Network Identification */
    void set_Nw_Id(NM_ECM_Nw_Id value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Network Identification */
    NM_ECM_Nw_Id get_Nw_Id() const { return (NM_ECM_Nw_Id)(raw >> 0 & 0xff); }
        
} NM_ECM;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_OBD_3D0 */
	uint32_t get_canid(){ return MS_OBD_3D0_CAN_ID; }
    /** Sets Pedal value for OBD. Conversion formula (To raw from real): y=(x-0.0)/0.39 (Unit: %) */
    void set_PW_OBD(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Pedal value for OBD. Conversion formula (To real from raw): y=(0.39x)+0.0 (Unit: %) */
    uint8_t get_PW_OBD() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Motorload for OBD. Conversion formula (To raw from real): y=(x-0.0)/0.39 (Unit: %) */
    void set_LOAD_OBD(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Motorload for OBD. Conversion formula (To real from raw): y=(0.39x)+0.0 (Unit: %) */
    uint8_t get_LOAD_OBD() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets S: */
    void set_ClrLgsDiagInfo(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets S: */
    bool get_ClrLgsDiagInfo() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets S: */
    void set_F_STAT_T_AUSSEN_AKTIV(bool value){ raw = (raw & 0xfffffeffffffffff) | ((uint64_t)value & 0x1) << 40; }

    /** Gets S: */
    bool get_F_STAT_T_AUSSEN_AKTIV() const { return (bool)(raw >> 40 & 0x1); }
        
    /** Sets Conditions for Ignition Cycle Counter (RBM) State */
    void set_OBD_IgnCycCntCond_Stat(MS_OBD_3D0h_OBD_IgnCycCntCond_Stat value){ raw = (raw & 0xffffffe7ffffffff) | ((uint64_t)value & 0x3) << 35; }

    /** Gets Conditions for Ignition Cycle Counter (RBM) State */
    MS_OBD_3D0h_OBD_IgnCycCntCond_Stat get_OBD_IgnCycCntCond_Stat() const { return (MS_OBD_3D0h_OBD_IgnCycCntCond_Stat)(raw >> 35 & 0x3); }
        
    /** Sets Conditions for General Denominator (RBM) State */
    void set_OBD_GnrlDenCond_Stat(MS_OBD_3D0h_OBD_GnrlDenCond_Stat value){ raw = (raw & 0xfffffff9ffffffff) | ((uint64_t)value & 0x3) << 33; }

    /** Gets Conditions for General Denominator (RBM) State */
    MS_OBD_3D0h_OBD_GnrlDenCond_Stat get_OBD_GnrlDenCond_Stat() const { return (MS_OBD_3D0h_OBD_GnrlDenCond_Stat)(raw >> 33 & 0x3); }
        
    /** Sets Conditions for warm-up fulfilled */
    void set_OBD_WarmupCond_Actv(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets Conditions for warm-up fulfilled */
    bool get_OBD_WarmupCond_Actv() const { return (bool)(raw >> 32 & 0x1); }
        
} MS_OBD_3D0;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_ANZ */
	uint32_t get_canid(){ return MS_ANZ_CAN_ID; }
    /** Sets Number of the ASS warning message */
    void set_ASS_WARN(MS_ANZ_ASS_WARN value){ raw = (raw & 0xffff0fffffffffff) | ((uint64_t)value & 0xf) << 44; }

    /** Gets Number of the ASS warning message */
    MS_ANZ_ASS_WARN get_ASS_WARN() const { return (MS_ANZ_ASS_WARN)(raw >> 44 & 0xf); }
        
    /** Sets Number of the ASS status message */
    void set_ASS_DSPL(MS_ANZ_ASS_DSPL value){ raw = (raw & 0xfffff0ffffffffff) | ((uint64_t)value & 0xf) << 40; }

    /** Gets Number of the ASS status message */
    MS_ANZ_ASS_DSPL get_ASS_DSPL() const { return (MS_ANZ_ASS_DSPL)(raw >> 40 & 0xf); }
        
    /** Sets Suppression of lamp test during stop phase */
    void set_ASS_LTEST_AUS(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Suppression of lamp test during stop phase */
    bool get_ASS_LTEST_AUS() const { return (bool)(raw >> 39 & 0x1); }
        
} MS_ANZ;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_608 */
	uint32_t get_canid(){ return MS_608_CAN_ID; }
    /** Sets engine coolant temperature */
    void set_T_MOT(MS_608h_T_MOT value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets engine coolant temperature */
    MS_608h_T_MOT get_T_MOT() const { return (MS_608h_T_MOT)(raw >> 56 & 0xff); }
        
    /** Sets intake air temperature */
    void set_T_LUFT(MS_608h_T_LUFT value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets intake air temperature */
    MS_608h_T_LUFT get_T_LUFT() const { return (MS_608h_T_LUFT)(raw >> 48 & 0xff); }
        
    /** Sets Vehicle code body */
    void set_FCOD_KAR(MS_608h_FCOD_KAR value){ raw = (raw & 0xffff1fffffffffff) | ((uint64_t)value & 0x7) << 45; }

    /** Gets Vehicle code body */
    MS_608h_FCOD_KAR get_FCOD_KAR() const { return (MS_608h_FCOD_KAR)(raw >> 45 & 0x7); }
        
    /** Sets Vehicle code series */
    void set_FCOD_BR(MS_608h_FCOD_BR value){ raw = (raw & 0xffffe0ffffffffff) | ((uint64_t)value & 0x1f) << 40; }

    /** Gets Vehicle code series */
    MS_608h_FCOD_BR get_FCOD_BR() const { return (MS_608h_FCOD_BR)(raw >> 40 & 0x1f); }
        
    /** Sets Vehicle code engine with 7 bits, bit 6 */
    void set_FCOD_MOT6(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Vehicle code engine with 7 bits, bit 6 */
    bool get_FCOD_MOT6() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Transmission control not available */
    void set_GS_NVH(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Transmission control not available */
    bool get_GS_NVH() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) */
    void set_FCOD_MOT(MS_608h_FCOD_MOT value){ raw = (raw & 0xffffffc0ffffffff) | ((uint64_t)value & 0x3f) << 32; }

    /** Gets FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) */
    MS_608h_FCOD_MOT get_FCOD_MOT() const { return (MS_608h_FCOD_MOT)(raw >> 32 & 0x3f); }
        
    /** Sets Fixed maximum speed */
    void set_V_MAX_FIX(MS_608h_V_MAX_FIX value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Fixed maximum speed */
    MS_608h_V_MAX_FIX get_V_MAX_FIX() const { return (MS_608h_V_MAX_FIX)(raw >> 24 & 0xff); }
        
    /** Sets consumption */
    void set_VB(MS_608h_VB value){ raw = (raw & 0xffffffffff0000ff) | ((uint64_t)value & 0xffff) << 8; }

    /** Gets consumption */
    MS_608h_VB get_VB() const { return (MS_608h_VB)(raw >> 8 & 0xffff); }
        
    /** Sets Request additional water pump */
    void set_ZWP_EIN_MS(bool value){ raw = (raw & 0xffffffffffffff7f) | ((uint64_t)value & 0x1) << 7; }

    /** Gets Request additional water pump */
    bool get_ZWP_EIN_MS() const { return (bool)(raw >> 7 & 0x1); }
        
    /** Sets particle filter warning */
    void set_PFW(MS_608h_PFW value){ raw = (raw & 0xffffffffffffff9f) | ((uint64_t)value & 0x3) << 5; }

    /** Gets particle filter warning */
    MS_608h_PFW get_PFW() const { return (MS_608h_PFW)(raw >> 5 & 0x3); }
        
    /** Sets Switch on additional consumers */
    void set_ZVB_EIN_MS(bool value){ raw = (raw & 0xffffffffffffffef) | ((uint64_t)value & 0x1) << 4; }

    /** Gets Switch on additional consumers */
    bool get_ZVB_EIN_MS() const { return (bool)(raw >> 4 & 0x1); }
        
    /** Sets Particle Filter Correction Offset FMMOTMAX */
    void set_PFKO(MS_608h_PFKO value){ raw = (raw & 0xfffffffffffffff0) | ((uint64_t)value & 0xf) << 0; }

    /** Gets Particle Filter Correction Offset FMMOTMAX */
    MS_608h_PFKO get_PFKO() const { return (MS_608h_PFKO)(raw >> 0 & 0xf); }
        
} MS_608;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_312 */
	uint32_t get_canid(){ return MS_312_CAN_ID; }
    /** Sets Motor torque static */
    void set_M_STA(MS_312h_M_STA value){ raw = (raw & 0xe000ffffffffffff) | ((uint64_t)value & 0x1fff) << 48; }

    /** Gets Motor torque static */
    MS_312h_M_STA get_M_STA() const { return (MS_312h_M_STA)(raw >> 48 & 0x1fff); }
        
    /** Sets Motor Torque Maximum incl. DYN.Turbocharger */
    void set_M_MAX_ATL(MS_312h_M_MAX_ATL value){ raw = (raw & 0xffffe000ffffffff) | ((uint64_t)value & 0x1fff) << 32; }

    /** Gets Motor Torque Maximum incl. DYN.Turbocharger */
    MS_312h_M_MAX_ATL get_M_MAX_ATL() const { return (MS_312h_M_MAX_ATL)(raw >> 32 & 0x1fff); }
        
    /** Sets Motor torque maximum */
    void set_M_MAX(MS_312h_M_MAX value){ raw = (raw & 0xffffffffe000ffff) | ((uint64_t)value & 0x1fff) << 16; }

    /** Gets Motor torque maximum */
    MS_312h_M_MAX get_M_MAX() const { return (MS_312h_M_MAX)(raw >> 16 & 0x1fff); }
        
    /** Sets Motor torque minimal */
    void set_M_MIN_SCHUB(MS_312h_M_MIN_SCHUB value){ raw = (raw & 0xffffffffffffe000) | ((uint64_t)value & 0x1fff) << 0; }

    /** Gets Motor torque minimal */
    MS_312h_M_MIN_SCHUB get_M_MIN_SCHUB() const { return (MS_312h_M_MIN_SCHUB)(raw >> 0 & 0x1fff); }
        
} MS_312;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_308 */
	uint32_t get_canid(){ return MS_308_CAN_ID; }
    /** Sets clutch kicked */
    void set_KPL(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets clutch kicked */
    bool get_KPL() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets start.Convertible bridging coupling 'Open' */
    void set_KUEB_O_A(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets start.Convertible bridging coupling 'Open' */
    bool get_KUEB_O_A() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Speed limiting function active */
    void set_N_MAX_BG(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Speed limiting function active */
    bool get_N_MAX_BG() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets part thrust shutdown */
    void set_SAST(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets part thrust shutdown */
    bool get_SAST() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets push shutdown full */
    void set_SASV(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets push shutdown full */
    bool get_SASV() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Fuel filter clogs control lamp (CR2 US only) */
    void set_KSF_KL(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Fuel filter clogs control lamp (CR2 US only) */
    bool get_KSF_KL() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Water in the fuel control lamp (CR2 US only) */
    void set_WKS_KL(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Water in the fuel control lamp (CR2 US only) */
    bool get_WKS_KL() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Cylinder shutdown conditions fulfilled */
    void set_ZASBED(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Cylinder shutdown conditions fulfilled */
    bool get_ZASBED() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets engine speed */
    void set_NMOT(MS_308h_NMOT value){ raw = (raw & 0xff0000ffffffffff) | ((uint64_t)value & 0xffff) << 40; }

    /** Gets engine speed */
    MS_308h_NMOT get_NMOT() const { return (MS_308h_NMOT)(raw >> 40 & 0xffff); }
        
    /** Sets S: */
    void set_PwrFreeD_Dsabl_Rq(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets S: */
    bool get_PwrFreeD_Dsabl_Rq() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Warning message Eco-Steerenkhelfpumpe */
    void set_ELHP_WARN(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Warning message Eco-Steerenkhelfpumpe */
    bool get_ELHP_WARN() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Ethanol operation detected */
    void set_EOH(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets Ethanol operation detected */
    bool get_EOH() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Air filter dirty warning lamp (only diesel) */
    void set_LUFI_KL(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Air filter dirty warning lamp (only diesel) */
    bool get_LUFI_KL() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets pre-glow control lamp */
    void set_VGL_KL(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets pre-glow control lamp */
    bool get_VGL_KL() const { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets oil level / oil pressure control lamp */
    void set_OEL_KL(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets oil level / oil pressure control lamp */
    bool get_OEL_KL() const { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets Diagnosis Control Lamp (OBD II) */
    void set_DIAG_KL(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets Diagnosis Control Lamp (OBD II) */
    bool get_DIAG_KL() const { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets Tank lid open check lamp */
    void set_TANK_KL(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets Tank lid open check lamp */
    bool get_TANK_KL() const { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets engine oil temperature too high (overheating) */
    void set_UEHITZ(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets engine oil temperature too high (overheating) */
    bool get_UEHITZ() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Coupling */
    void set_KPL2(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Coupling */
    bool get_KPL2() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets ADR check lamp (NFZ only) */
    void set_ADR_KL(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets ADR check lamp (NFZ only) */
    bool get_ADR_KL() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets ADR defective control lamp (NFZ only) */
    void set_ADR_DEF_KL(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets ADR defective control lamp (NFZ only) */
    bool get_ADR_DEF_KL() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets starter is running */
    void set_ANL_LFT(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets starter is running */
    bool get_ANL_LFT() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Motor Heater Defective Control Lamp */
    void set_LUEFT_MOT_KL(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Motor Heater Defective Control Lamp */
    bool get_LUEFT_MOT_KL() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets Speed limitation for display active (0 at CR) */
    void set_DBAA(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets Speed limitation for display active (0 at CR) */
    bool get_DBAA() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets cooling water temperature too high */
    void set_TEMP_KL(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets cooling water temperature too high */
    bool get_TEMP_KL() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets Oil temperature */
    void set_T_OEL(MS_308h_T_OEL value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Oil temperature */
    MS_308h_T_OEL get_T_OEL() const { return (MS_308h_T_OEL)(raw >> 16 & 0xff); }
        
    /** Sets oil level */
    void set_OEL_FS(MS_308h_OEL_FS value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets oil level */
    MS_308h_OEL_FS get_OEL_FS() const { return (MS_308h_OEL_FS)(raw >> 8 & 0xff); }
        
    /** Sets oil quality */
    void set_OEL_QUAL(MS_308h_OEL_QUAL value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets oil quality */
    MS_308h_OEL_QUAL get_OEL_QUAL() const { return (MS_308h_OEL_QUAL)(raw >> 0 & 0xff); }
        
} MS_308;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_2F3 */
	uint32_t get_canid(){ return MS_2F3_CAN_ID; }
    /** Sets Engine Vacuum State */
    void set_Eng_Vac_Stat(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Engine Vacuum State */
    bool get_Eng_Vac_Stat() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Powertrain Ready */
    void set_PT_Rdy(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Powertrain Ready */
    bool get_PT_Rdy() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Start-Stop Automatic Prewarning Engine Stop */
    void set_SSA_Sp_Warn(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Start-Stop Automatic Prewarning Engine Stop */
    bool get_SSA_Sp_Warn() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Start / Stop Automatic Has Engine Stoped */
    void set_SSA_EngSp(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Start / Stop Automatic Has Engine Stoped */
    bool get_SSA_EngSp() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Neutral Gear State */
    void set_GrN_Stat(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Neutral Gear State */
    bool get_GrN_Stat() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Engine Running State */
    void set_EngRun_Stat(MS_2F3h_EngRun_Stat value){ raw = (raw & 0xf8ffffffffffffff) | ((uint64_t)value & 0x7) << 56; }

    /** Gets Engine Running State */
    MS_2F3h_EngRun_Stat get_EngRun_Stat() const { return (MS_2F3h_EngRun_Stat)(raw >> 56 & 0x7); }
        
    /** Sets Transmission Driving Position Display Request */
    void set_TxDrvPosn_Disp_Rq(MS_2F3h_TxDrvPosn_Disp_Rq value){ raw = (raw & 0xff0fffffffffffff) | ((uint64_t)value & 0xf) << 52; }

    /** Gets Transmission Driving Position Display Request */
    MS_2F3h_TxDrvPosn_Disp_Rq get_TxDrvPosn_Disp_Rq() const { return (MS_2F3h_TxDrvPosn_Disp_Rq)(raw >> 52 & 0xf); }
        
    /** Sets Proposed Target Gear */
    void set_Gr_Target_Prop_Disp_Rq(MS_2F3h_Gr_Target_Prop_Disp_Rq value){ raw = (raw & 0xfff3ffffffffffff) | ((uint64_t)value & 0x3) << 50; }

    /** Gets Proposed Target Gear */
    MS_2F3h_Gr_Target_Prop_Disp_Rq get_Gr_Target_Prop_Disp_Rq() const { return (MS_2F3h_Gr_Target_Prop_Disp_Rq)(raw >> 50 & 0x3); }
        
    /** Sets Eco LED on Request */
    void set_ECO_LED_On_Rq(MS_2F3h_ECO_LED_On_Rq value){ raw = (raw & 0xfffcffffffffffff) | ((uint64_t)value & 0x3) << 48; }

    /** Gets Eco LED on Request */
    MS_2F3h_ECO_LED_On_Rq get_ECO_LED_On_Rq() const { return (MS_2F3h_ECO_LED_On_Rq)(raw >> 48 & 0x3); }
        
    /** Sets Actual Engine Idle Speed Level */
    void set_EngIdleRPMLevel_Act(MS_2F3h_EngIdleRPMLevel_Act value){ raw = (raw & 0xffffe7ffffffffff) | ((uint64_t)value & 0x3) << 43; }

    /** Gets Actual Engine Idle Speed Level */
    MS_2F3h_EngIdleRPMLevel_Act get_EngIdleRPMLevel_Act() const { return (MS_2F3h_EngIdleRPMLevel_Act)(raw >> 43 & 0x3); }
        
    /** Sets Motorn dot with elevated maximum speed */
    void set_NOTL2(bool value){ raw = (raw & 0xfffffbffffffffff) | ((uint64_t)value & 0x1) << 42; }

    /** Gets Motorn dot with elevated maximum speed */
    bool get_NOTL2() const { return (bool)(raw >> 42 & 0x1); }
        
    /** Sets Suppression of lamp test during stop phase */
    void set_ASS_LTEST_AUS(bool value){ raw = (raw & 0xfffffdffffffffff) | ((uint64_t)value & 0x1) << 41; }

    /** Gets Suppression of lamp test during stop phase */
    bool get_ASS_LTEST_AUS() const { return (bool)(raw >> 41 & 0x1); }
        
    /** Sets Eco Message on Request */
    void set_ECO_MsgOn_Rq(bool value){ raw = (raw & 0xfffffeffffffffff) | ((uint64_t)value & 0x1) << 40; }

    /** Gets Eco Message on Request */
    bool get_ECO_MsgOn_Rq() const { return (bool)(raw >> 40 & 0x1); }
        
} MS_2F3;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_268 */
	uint32_t get_canid(){ return MS_268_CAN_ID; }
    /** Sets target translation, lower border (FCVT) */
    void set_IMIN_MS(MS_268h_IMIN_MS value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets target translation, lower border (FCVT) */
    MS_268h_IMIN_MS get_IMIN_MS() const { return (MS_268h_IMIN_MS)(raw >> 56 & 0xff); }
        
    /** Sets Target Translation, Upper Border (FCVT) */
    void set_IMAX_MS(MS_268h_IMAX_MS value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Target Translation, Upper Border (FCVT) */
    MS_268h_IMAX_MS get_IMAX_MS() const { return (MS_268h_IMAX_MS)(raw >> 48 & 0xff); }
        
    /** Sets Terminal 61 is switched on */
    void set_KL_61_EIN(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Terminal 61 is switched on */
    bool get_KL_61_EIN() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Oil Info BR 169, reserved M266 */
    void set_OEL_INFO_169(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Oil Info BR 169, reserved M266 */
    bool get_OEL_INFO_169() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets shut-off valve cooling circuit M266 ATL */
    void set_ASV_KKL_169(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets shut-off valve cooling circuit M266 ATL */
    bool get_ASV_KKL_169() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets Engine exhaust aftertreatment active */
    void set_MOT_ABGASNACHBEH_AKT(bool value){ raw = (raw & 0xffffefffffffffff) | ((uint64_t)value & 0x1) << 44; }

    /** Gets Engine exhaust aftertreatment active */
    bool get_MOT_ABGASNACHBEH_AKT() const { return (bool)(raw >> 44 & 0x1); }
        
    /** Sets Plausibilization Tomentic increase GS through, enabled intervention */
    void set_PLAUS_M_ERH_G_ENBL(bool value){ raw = (raw & 0xfffff7ffffffffff) | ((uint64_t)value & 0x1) << 43; }

    /** Gets Plausibilization Tomentic increase GS through, enabled intervention */
    bool get_PLAUS_M_ERH_G_ENBL() const { return (bool)(raw >> 43 & 0x1); }
        
    /** Sets Plausibilization FKT.Moment increase from the gearbox available */
    void set_PLAUS_M_ERH_G_VH(bool value){ raw = (raw & 0xfffffbffffffffff) | ((uint64_t)value & 0x1) << 42; }

    /** Gets Plausibilization FKT.Moment increase from the gearbox available */
    bool get_PLAUS_M_ERH_G_VH() const { return (bool)(raw >> 42 & 0x1); }
        
    /** Sets Status heating power */
    void set_HZL_ST(MS_268h_HZL_ST value){ raw = (raw & 0xfffffcffffffffff) | ((uint64_t)value & 0x3) << 40; }

    /** Gets Status heating power */
    MS_268h_HZL_ST get_HZL_ST() const { return (MS_268h_HZL_ST)(raw >> 40 & 0x3); }
        
    /** Sets Request for power-free in 'd' (FCVT) */
    void set_KID_MS(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Request for power-free in 'd' (FCVT) */
    bool get_KID_MS() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets S: */
    void set_LRS_MODE(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets S: */
    bool get_LRS_MODE() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Generator utilization (LIN generators only!) */
    void set_LAST_GEN(MS_268h_LAST_GEN value){ raw = (raw & 0xffffffc0ffffffff) | ((uint64_t)value & 0x3f) << 32; }

    /** Gets Generator utilization (LIN generators only!) */
    MS_268h_LAST_GEN get_LAST_GEN() const { return (MS_268h_LAST_GEN)(raw >> 32 & 0x3f); }
        
    /** Sets Max. Climate compressor torque (only 169) */
    void set_M_KOMP_MAX(MS_268h_M_KOMP_MAX value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Max. Climate compressor torque (only 169) */
    MS_268h_M_KOMP_MAX get_M_KOMP_MAX() const { return (MS_268h_M_KOMP_MAX)(raw >> 24 & 0xff); }
        
    /** Sets pedal value driver */
    void set_PW_F(MS_268h_PW_F value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets pedal value driver */
    MS_268h_PW_F get_PW_F() const { return (MS_268h_PW_F)(raw >> 16 & 0xff); }
        
    /** Sets Target voltage specification generator */
    void set_ALT_OUTDC_V_ECM(MS_268h_ALT_OUTDC_V_ECM value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets Target voltage specification generator */
    MS_268h_ALT_OUTDC_V_ECM get_ALT_OUTDC_V_ECM() const { return (MS_268h_ALT_OUTDC_V_ECM)(raw >> 8 & 0xff); }
        
    /** Sets Maximum controller current specification generator */
    void set_ALT_EXCCURR_ECM(MS_268h_ALT_EXCCURR_ECM value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Maximum controller current specification generator */
    MS_268h_ALT_EXCCURR_ECM get_ALT_EXCCURR_ECM() const { return (MS_268h_ALT_EXCCURR_ECM)(raw >> 0 & 0xff); }
        
} MS_268;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_212 */
	uint32_t get_canid(){ return MS_212_CAN_ID; }
    /** Sets Motorle-rolling speed */
    void set_NMOTS(MS_212h_NMOTS value){ raw = (raw & 0x0000ffffffffffff) | ((uint64_t)value & 0xffff) << 48; }

    /** Gets Motorle-rolling speed */
    MS_212h_NMOTS get_NMOTS() const { return (MS_212h_NMOTS)(raw >> 48 & 0xffff); }
        
    /** Sets Parity bit via M_ESPV */
    void set_M_ESPV_PA(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Parity bit via M_ESPV */
    bool get_M_ESPV_PA() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Serial mpomat is variant encoded */
    void set_TM_MS(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Serial mpomat is variant encoded */
    bool get_TM_MS() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Enable torque requirement type */
    void set_M_ART_E(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Enable torque requirement type */
    bool get_M_ART_E() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets default torque driver */
    void set_M_FV(MS_212h_M_FV value){ raw = (raw & 0xffffe000ffffffff) | ((uint64_t)value & 0x1fff) << 32; }

    /** Gets default torque driver */
    MS_212h_M_FV get_M_FV() const { return (MS_212h_M_FV)(raw >> 32 & 0x1fff); }
        
    /** Sets Toggle bit via M_ESPV */
    void set_M_ESPV_TGL(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Toggle bit via M_ESPV */
    bool get_M_ESPV_TGL() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets ENABLE Fast torque setting */
    void set_SME_E(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets ENABLE Fast torque setting */
    bool get_SME_E() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Enable torque requirement ESP */
    void set_M_ESP_E(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Enable torque requirement ESP */
    bool get_M_ESP_E() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets replacement feed torque driver */
    void set_M_FEV(MS_212h_M_FEV value){ raw = (raw & 0xffffffffe000ffff) | ((uint64_t)value & 0x1fff) << 16; }

    /** Gets replacement feed torque driver */
    MS_212h_M_FEV get_M_FEV() const { return (MS_212h_M_FEV)(raw >> 16 & 0x1fff); }
        
    /** Sets Transfer Calid / CVN Enable */
    void set_CALID_CVN_E(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Transfer Calid / CVN Enable */
    bool get_CALID_CVN_E() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets acknowledgment torque requirement EGS */
    void set_M_EGS_Q(bool value){ raw = (raw & 0xffffffffffffbfff) | ((uint64_t)value & 0x1) << 14; }

    /** Gets acknowledgment torque requirement EGS */
    bool get_M_EGS_Q() const { return (bool)(raw >> 14 & 0x1); }
        
    /** Sets Enable torque requirement EGS */
    void set_M_EGS_E(bool value){ raw = (raw & 0xffffffffffffdfff) | ((uint64_t)value & 0x1) << 13; }

    /** Gets Enable torque requirement EGS */
    bool get_M_EGS_E() const { return (bool)(raw >> 13 & 0x1); }
        
    /** Sets Property torque ESP incl. Shear content */
    void set_M_ESPV_SCHUB(MS_212h_M_ESPV_SCHUB value){ raw = (raw & 0xffffffffffffe000) | ((uint64_t)value & 0x1fff) << 0; }

    /** Gets Property torque ESP incl. Shear content */
    MS_212h_M_ESPV_SCHUB get_M_ESPV_SCHUB() const { return (MS_212h_M_ESPV_SCHUB)(raw >> 0 & 0x1fff); }
        
} MS_212;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of MS_210 */
	uint32_t get_canid(){ return MS_210_CAN_ID; }
    /** Sets Cold Compressor Emergency Switch Off */
    void set_KOMP_NOTAUS(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Cold Compressor Emergency Switch Off */
    bool get_KOMP_NOTAUS() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Switching shift MS */
    void set_SLV_MS(MS_210h_SLV_MS value){ raw = (raw & 0x87ffffffffffffff) | ((uint64_t)value & 0xf) << 59; }

    /** Gets Switching shift MS */
    MS_210h_SLV_MS get_SLV_MS() const { return (MS_210h_SLV_MS)(raw >> 59 & 0xf); }
        
    /** Sets Turn-speed */
    void set_DZGBR_NTLF(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Turn-speed */
    bool get_DZGBR_NTLF() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets turn off KSG crawl */
    void set_KRIECH_AUS(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets turn off KSG crawl */
    bool get_KRIECH_AUS() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets MS wish: 'startup 1st gear' */
    void set_ANF1(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets MS wish: 'startup 1st gear' */
    bool get_ANF1() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets MS-WIS'Active recovering' */
    void set_AKT_R_MS(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets MS-WIS'Active recovering' */
    bool get_AKT_R_MS() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets S: */
    void set_MSS_TUER(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets S: */
    bool get_MSS_TUER() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets Sprocket, upper limit */
    void set_GMAX_MS(MS_210h_GMAX_MS value){ raw = (raw & 0xffc7ffffffffffff) | ((uint64_t)value & 0x7) << 51; }

    /** Gets Sprocket, upper limit */
    MS_210h_GMAX_MS get_GMAX_MS() const { return (MS_210h_GMAX_MS)(raw >> 51 & 0x7); }
        
    /** Sets Sprocket, lower limit */
    void set_GMIN_MS(MS_210h_GMIN_MS value){ raw = (raw & 0xfff8ffffffffffff) | ((uint64_t)value & 0x7) << 48; }

    /** Gets Sprocket, lower limit */
    MS_210h_GMIN_MS get_GMIN_MS() const { return (MS_210h_GMIN_MS)(raw >> 48 & 0x7); }
        
    /** Sets pedal value */
    void set_PW(MS_210h_PW value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets pedal value */
    MS_210h_PW get_PW() const { return (MS_210h_PW)(raw >> 40 & 0xff); }
        
    /** Sets Minimum display time in the display new trigger */
    void set_V_DSPL_NEU(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Minimum display time in the display new trigger */
    bool get_V_DSPL_NEU() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets idle is stable */
    void set_LL_STBL(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets idle is stable */
    bool get_LL_STBL() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets preheat status */
    void set_VGL_ST(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets preheat status */
    bool get_VGL_ST() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Motor Start / Stop plant defective */
    void set_MSS_DEF(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Motor Start / Stop plant defective */
    bool get_MSS_DEF() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets Motor Start / Stop Plant Control Lamp */
    void set_MSS_KL(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets Motor Start / Stop Plant Control Lamp */
    bool get_MSS_KL() const { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets Motor Start / Stop system active */
    void set_MSS_AKT(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets Motor Start / Stop system active */
    bool get_MSS_AKT() const { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets Switch off the cooling compressor: acceleration */
    void set_KOMP_BAUS(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets Switch off the cooling compressor: acceleration */
    bool get_KOMP_BAUS() const { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets Crash signal from engine control */
    void set_CRASH_MS(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets Crash signal from engine control */
    bool get_CRASH_MS() const { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets Error pedal value encoder */
    void set_PWG_ERR(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Error pedal value encoder */
    bool get_PWG_ERR() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets idle */
    void set_LL(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets idle */
    bool get_LL() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets start. Convertible bridging clutch 'slip' */
    void set_KUEB_S_A(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets start. Convertible bridging clutch 'slip' */
    bool get_KUEB_S_A() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Tempomat regulates */
    void set_TM_REG(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets Tempomat regulates */
    bool get_TM_REG() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets Speed ​​limitation switched on */
    void set_V_MAX_EIN(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets Speed ​​limitation switched on */
    bool get_V_MAX_EIN() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Kickdown (conversion scenario open!) */
    void set_KD_MS(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Kickdown (conversion scenario open!) */
    bool get_KD_MS() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets emergency operation */
    void set_NOTL(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets emergency operation */
    bool get_NOTL() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets Warning Number */
    void set_V_MAX_SUM(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets Warning Number */
    bool get_V_MAX_SUM() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets FBStart Error */
    void set_FBS_SE(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets FBStart Error */
    bool get_FBS_SE() const { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets Display 'Winter tire limit reached' on the display */
    void set_V_DSPL_PGB(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets Display 'Winter tire limit reached' on the display */
    bool get_V_DSPL_PGB() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets Tempomat turned on */
    void set_TM_EIN(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets Tempomat turned on */
    bool get_TM_EIN() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets Speed ​​limiter regulates */
    void set_V_MAX_REG(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets Speed ​​limiter regulates */
    bool get_V_MAX_REG() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets Display 'Limit?' on the display */
    void set_V_DSPL_LIM(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets Display 'Limit?' on the display */
    bool get_V_DSPL_LIM() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets Display 'Error' on the display */
    void set_V_DSPL_ERR(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Display 'Error' on the display */
    bool get_V_DSPL_ERR() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets Display flashes */
    void set_V_DSPL_BL(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets Display flashes */
    bool get_V_DSPL_BL() const { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets Surrupy / Tempomat display */
    void set_V_DSPL_EIN(bool value){ raw = (raw & 0xfffffffffffeffff) | ((uint64_t)value & 0x1) << 16; }

    /** Gets Surrupy / Tempomat display */
    bool get_V_DSPL_EIN() const { return (bool)(raw >> 16 & 0x1); }
        
    /** Sets factor for departure. d. Max. Mom. At Aufneh. A.Print */
    void set_FMMOTMAX(MS_210h_FMMOTMAX value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets factor for departure. d. Max. Mom. At Aufneh. A.Print */
    MS_210h_FMMOTMAX get_FMMOTMAX() const { return (MS_210h_FMMOTMAX)(raw >> 8 & 0xff); }
        
    /** Sets set maximum or cruise speed */
    void set_V_MAX_TM(MS_210h_V_MAX_TM value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets set maximum or cruise speed */
    MS_210h_V_MAX_TM get_V_MAX_TM() const { return (MS_210h_V_MAX_TM)(raw >> 0 & 0xff); }
        
} MS_210;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of CNG_ANZ */
	uint32_t get_canid(){ return CNG_ANZ_CAN_ID; }
    /** Sets Tank level natural gas */
    void set_TANK_FS_GAS(CNG_ANZ_TANK_FS_GAS value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Tank level natural gas */
    CNG_ANZ_TANK_FS_GAS get_TANK_FS_GAS() const { return (CNG_ANZ_TANK_FS_GAS)(raw >> 56 & 0xff); }
        
    /** Sets Confirmation mode switching */
    void set_BTRBSART_UMSCH_BEST(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets Confirmation mode switching */
    bool get_BTRBSART_UMSCH_BEST() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets operating mode */
    void set_BTRBSART(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets operating mode */
    bool get_BTRBSART() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets operating mode switching active */
    void set_BTRBSART_UMSCH_AKTIV(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets operating mode switching active */
    bool get_BTRBSART_UMSCH_AKTIV() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets Status Current operating mode */
    void set_BTRBSART_STATUS(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets Status Current operating mode */
    bool get_BTRBSART_STATUS() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets natural gas fuel lid open warning lamp */
    void set_TANK_KL_GAS(bool value){ raw = (raw & 0xfffdffffffffffff) | ((uint64_t)value & 0x1) << 49; }

    /** Gets natural gas fuel lid open warning lamp */
    bool get_TANK_KL_GAS() const { return (bool)(raw >> 49 & 0x1); }
        
    /** Sets Tank level minimum natural gas */
    void set_TFSM_GAS(bool value){ raw = (raw & 0xfffeffffffffffff) | ((uint64_t)value & 0x1) << 48; }

    /** Gets Tank level minimum natural gas */
    bool get_TFSM_GAS() const { return (bool)(raw >> 48 & 0x1); }
        
    /** Sets Message '' */
    void set_CNG_M8(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Message '' */
    bool get_CNG_M8() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Message '' */
    void set_CNG_M7(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Message '' */
    bool get_CNG_M7() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Message '' */
    void set_CNG_M6(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Message '' */
    bool get_CNG_M6() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets Message '' */
    void set_CNG_M5(bool value){ raw = (raw & 0xffffefffffffffff) | ((uint64_t)value & 0x1) << 44; }

    /** Gets Message '' */
    bool get_CNG_M5() const { return (bool)(raw >> 44 & 0x1); }
        
    /** Sets Message 'Ban Operating Type Gasoline due to fault' */
    void set_CNG_M4(bool value){ raw = (raw & 0xfffff7ffffffffff) | ((uint64_t)value & 0x1) << 43; }

    /** Gets Message 'Ban Operating Type Gasoline due to fault' */
    bool get_CNG_M4() const { return (bool)(raw >> 43 & 0x1); }
        
    /** Sets Message 'Prohibition Operating Type Gasoline due to level too low' */
    void set_CNG_M3(bool value){ raw = (raw & 0xfffffbffffffffff) | ((uint64_t)value & 0x1) << 42; }

    /** Gets Message 'Prohibition Operating Type Gasoline due to level too low' */
    bool get_CNG_M3() const { return (bool)(raw >> 42 & 0x1); }
        
    /** Sets Message 'Prohibition mode Natural gas due to fault' */
    void set_CNG_M2(bool value){ raw = (raw & 0xfffffdffffffffff) | ((uint64_t)value & 0x1) << 41; }

    /** Gets Message 'Prohibition mode Natural gas due to fault' */
    bool get_CNG_M2() const { return (bool)(raw >> 41 & 0x1); }
        
    /** Sets Message 'Ban operating mode natural gas due to level too low' */
    void set_CNG_M1(bool value){ raw = (raw & 0xfffffeffffffffff) | ((uint64_t)value & 0x1) << 40; }

    /** Gets Message 'Ban operating mode natural gas due to level too low' */
    bool get_CNG_M1() const { return (bool)(raw >> 40 & 0x1); }
        
    /** Sets high pressure CNG */
    void set_P_CNG(CNG_ANZ_P_CNG value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets high pressure CNG */
    CNG_ANZ_P_CNG get_P_CNG() const { return (CNG_ANZ_P_CNG)(raw >> 32 & 0xff); }
        
} CNG_ANZ;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ADBLUE_DISP_RQ */
	uint32_t get_canid(){ return ADBLUE_DISP_RQ_CAN_ID; }
    /** Sets AdBlue Remaining Distance */
    void set_Adblue_RemainDist(ADBLUE_DISP_RQ_Adblue_RemainDist value){ raw = (raw & 0x0000ffffffffffff) | ((uint64_t)value & 0xffff) << 48; }

    /** Gets AdBlue Remaining Distance */
    ADBLUE_DISP_RQ_Adblue_RemainDist get_Adblue_RemainDist() const { return (ADBLUE_DISP_RQ_Adblue_RemainDist)(raw >> 48 & 0xffff); }
        
    /** Sets AdBlue Reserve Marker of AdBlue Fuel Level */
    void set_AdBlue_ResMrk_Disp(ADBLUE_DISP_RQ_AdBlue_ResMrk_Disp value){ raw = (raw & 0xffff3fffffffffff) | ((uint64_t)value & 0x3) << 46; }

    /** Gets AdBlue Reserve Marker of AdBlue Fuel Level */
    ADBLUE_DISP_RQ_AdBlue_ResMrk_Disp get_AdBlue_ResMrk_Disp() const { return (ADBLUE_DISP_RQ_AdBlue_ResMrk_Disp)(raw >> 46 & 0x3); }
        
    /** Sets View Text in Instrument Cluster of the Possible Values */
    void set_AdBlue_MenueTxt_Disp(ADBLUE_DISP_RQ_AdBlue_MenueTxt_Disp value){ raw = (raw & 0xffffc7ffffffffff) | ((uint64_t)value & 0x7) << 43; }

    /** Gets View Text in Instrument Cluster of the Possible Values */
    ADBLUE_DISP_RQ_AdBlue_MenueTxt_Disp get_AdBlue_MenueTxt_Disp() const { return (ADBLUE_DISP_RQ_AdBlue_MenueTxt_Disp)(raw >> 43 & 0x7); }
        
    /** Sets Start Restriction Counter */
    void set_Adblue_WarnLvl3(bool value){ raw = (raw & 0xfffffbffffffffff) | ((uint64_t)value & 0x1) << 42; }

    /** Gets Start Restriction Counter */
    bool get_Adblue_WarnLvl3() const { return (bool)(raw >> 42 & 0x1); }
        
    /** Sets Check Fluid */
    void set_Adblue_WarnLvl2(bool value){ raw = (raw & 0xfffffdffffffffff) | ((uint64_t)value & 0x1) << 41; }

    /** Gets Check Fluid */
    bool get_Adblue_WarnLvl2() const { return (bool)(raw >> 41 & 0x1); }
        
    /** Sets Tank Full */
    void set_Adblue_WarnLvl1(bool value){ raw = (raw & 0xfffffeffffffffff) | ((uint64_t)value & 0x1) << 40; }

    /** Gets Tank Full */
    bool get_Adblue_WarnLvl1() const { return (bool)(raw >> 40 & 0x1); }
        
    /** Sets AdBlue (EU6) Refill and Check Message Display Request Fashion */
    void set_AdblueEU6_RefillChkMsg_Md(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets AdBlue (EU6) Refill and Check Message Display Request Fashion */
    bool get_AdblueEU6_RefillChkMsg_Md() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Show Replacement View in Case of Scrcm Failure */
    void set_AdBlue_ReplView_Disp_Rq(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Show Replacement View in Case of Scrcm Failure */
    bool get_AdBlue_ReplView_Disp_Rq() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Remaining Engine Starts. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_EngSt_Remain(uint8_t value){ raw = (raw & 0xffffffc0ffffffff) | ((uint64_t)value & 0x3f) << 32; }

    /** Gets Remaining Engine Starts. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_EngSt_Remain() const { return (uint8_t)(raw >> 32 & 0x3f); }
        
    /** Sets AdBlue (EU6) Check Message Display Request */
    void set_AdblueEU6_ChkMsg_Disp_Rq_V2(ADBLUE_DISP_RQ_AdblueEU6_ChkMsg_Disp_Rq_V2 value){ raw = (raw & 0xffffffff3fffffff) | ((uint64_t)value & 0x3) << 30; }

    /** Gets AdBlue (EU6) Check Message Display Request */
    ADBLUE_DISP_RQ_AdblueEU6_ChkMsg_Disp_Rq_V2 get_AdblueEU6_ChkMsg_Disp_Rq_V2() const { return (ADBLUE_DISP_RQ_AdblueEU6_ChkMsg_Disp_Rq_V2)(raw >> 30 & 0x3); }
        
    /** Sets AdBlue (EU6) Refill Message Display Request */
    void set_AdblueEU6_RefillMsg_Disp_Rq_V2(ADBLUE_DISP_RQ_AdblueEU6_RefillMsg_Disp_Rq_V2 value){ raw = (raw & 0xffffffffcfffffff) | ((uint64_t)value & 0x3) << 28; }

    /** Gets AdBlue (EU6) Refill Message Display Request */
    ADBLUE_DISP_RQ_AdblueEU6_RefillMsg_Disp_Rq_V2 get_AdblueEU6_RefillMsg_Disp_Rq_V2() const { return (ADBLUE_DISP_RQ_AdblueEU6_RefillMsg_Disp_Rq_V2)(raw >> 28 & 0x3); }
        
    /** Sets Remaining Distance Until 'No Restart' (EU6) */
    void set_AdblueEU6_RemainDist(ADBLUE_DISP_RQ_AdblueEU6_RemainDist value){ raw = (raw & 0xfffffffff000ffff) | ((uint64_t)value & 0xfff) << 16; }

    /** Gets Remaining Distance Until 'No Restart' (EU6) */
    ADBLUE_DISP_RQ_AdblueEU6_RemainDist get_AdblueEU6_RemainDist() const { return (ADBLUE_DISP_RQ_AdblueEU6_RemainDist)(raw >> 16 & 0xfff); }
        
    /** Sets Retrigger Display Remaining Distance (EU6) */
    void set_AdblueEU6_Msg_Disp_TrgrRq(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Retrigger Display Remaining Distance (EU6) */
    bool get_AdblueEU6_Msg_Disp_TrgrRq() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets Level AdBlue Tank */
    void set_AdBlue_TankLvl_Disp_Rq(ADBLUE_DISP_RQ_AdBlue_TankLvl_Disp_Rq value){ raw = (raw & 0xffffffffffff80ff) | ((uint64_t)value & 0x7f) << 8; }

    /** Gets Level AdBlue Tank */
    ADBLUE_DISP_RQ_AdBlue_TankLvl_Disp_Rq get_AdBlue_TankLvl_Disp_Rq() const { return (ADBLUE_DISP_RQ_AdBlue_TankLvl_Disp_Rq)(raw >> 8 & 0x7f); }
        
    /** Sets Range AdBlue tank for the service display */
    void set_Adblue_RemainDistSrvce_Disp(ADBLUE_DISP_RQ_Adblue_RemainDistSrvce_Disp value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Range AdBlue tank for the service display */
    ADBLUE_DISP_RQ_Adblue_RemainDistSrvce_Disp get_Adblue_RemainDistSrvce_Disp() const { return (ADBLUE_DISP_RQ_Adblue_RemainDistSrvce_Disp)(raw >> 0 & 0xff); }
        
} ADBLUE_DISP_RQ;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of AAD_580 */
	uint32_t get_canid(){ return AAD_580_CAN_ID; }
    /** Sets indicator acceleration type (> 100: dynamic) */
    void set_FTK_BMI(AAD_580h_FTK_BMI value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets indicator acceleration type (> 100: dynamic) */
    AAD_580h_FTK_BMI get_FTK_BMI() const { return (AAD_580h_FTK_BMI)(raw >> 56 & 0xff); }
        
    /** Sets code number of transverse acceleration type (> 100: dynamic) */
    void set_FTK_LMI(AAD_580h_FTK_LMI value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets code number of transverse acceleration type (> 100: dynamic) */
    AAD_580h_FTK_LMI get_FTK_LMI() const { return (AAD_580h_FTK_LMI)(raw >> 48 & 0xff); }
        
    /** Sets code number brake type (> 100: dynamic) */
    void set_FTK_VMI(AAD_580h_FTK_VMI value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets code number brake type (> 100: dynamic) */
    AAD_580h_FTK_VMI get_FTK_VMI() const { return (AAD_580h_FTK_VMI)(raw >> 40 & 0xff); }
        
    /** Sets Max. Diff.Pedal angle value per maneuver */
    void set_FTK_DPW(AAD_580h_FTK_DPW value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Max. Diff.Pedal angle value per maneuver */
    AAD_580h_FTK_DPW get_FTK_DPW() const { return (AAD_580h_FTK_DPW)(raw >> 24 & 0xff); }
        
    /** Sets Continuous driver watching */
    void set_AADKB(AAD_580h_AADKB value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Continuous driver watching */
    AAD_580h_AADKB get_AADKB() const { return (AAD_580h_AADKB)(raw >> 16 & 0xff); }
        
    /** Sets Spontaneous dynamic requirement */
    void set_AADKBDYN(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Spontaneous dynamic requirement */
    bool get_AADKBDYN() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets nervousness */
    void set_AADNT(AAD_580h_AADNT value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets nervousness */
    AAD_580h_AADNT get_AADNT() const { return (AAD_580h_AADNT)(raw >> 0 & 0xff); }
        
} AAD_580;



class ECU_MS {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case TC_EBBC_DISP_RQ_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case TC_DISP_RQ_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case SG_A1_ECM_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case NM_ECM_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case MS_OBD_3D0_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case MS_ANZ_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                case MS_608_CAN_ID:
                    LAST_FRAME_TIMES[6] = timestamp_now;
                    FRAME_DATA[6] = value;
                    return true;
                case MS_312_CAN_ID:
                    LAST_FRAME_TIMES[7] = timestamp_now;
                    FRAME_DATA[7] = value;
                    return true;
                case MS_308_CAN_ID:
                    LAST_FRAME_TIMES[8] = timestamp_now;
                    FRAME_DATA[8] = value;
                    return true;
                case MS_2F3_CAN_ID:
                    LAST_FRAME_TIMES[9] = timestamp_now;
                    FRAME_DATA[9] = value;
                    return true;
                case MS_268_CAN_ID:
                    LAST_FRAME_TIMES[10] = timestamp_now;
                    FRAME_DATA[10] = value;
                    return true;
                case MS_212_CAN_ID:
                    LAST_FRAME_TIMES[11] = timestamp_now;
                    FRAME_DATA[11] = value;
                    return true;
                case MS_210_CAN_ID:
                    LAST_FRAME_TIMES[12] = timestamp_now;
                    FRAME_DATA[12] = value;
                    return true;
                case CNG_ANZ_CAN_ID:
                    LAST_FRAME_TIMES[13] = timestamp_now;
                    FRAME_DATA[13] = value;
                    return true;
                case ADBLUE_DISP_RQ_CAN_ID:
                    LAST_FRAME_TIMES[14] = timestamp_now;
                    FRAME_DATA[14] = value;
                    return true;
                case AAD_580_CAN_ID:
                    LAST_FRAME_TIMES[15] = timestamp_now;
                    FRAME_DATA[15] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to TC_EBBC_DISP_RQ
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_TC_EBBC_DISP_RQ(uint64_t now, uint64_t max_expire_time, TC_EBBC_DISP_RQ* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to TC_DISP_RQ
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_TC_DISP_RQ(uint64_t now, uint64_t max_expire_time, TC_DISP_RQ* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to SG_A1_ECM
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SG_A1_ECM(uint64_t now, uint64_t max_expire_time, SG_A1_ECM* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to NM_ECM
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_NM_ECM(uint64_t now, uint64_t max_expire_time, NM_ECM* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_OBD_3D0
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_OBD_3D0(uint64_t now, uint64_t max_expire_time, MS_OBD_3D0* dest) const {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[4] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[4];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_ANZ
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_ANZ(uint64_t now, uint64_t max_expire_time, MS_ANZ* dest) const {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[5] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[5];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_608
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_608(uint64_t now, uint64_t max_expire_time, MS_608* dest) const {
            if (LAST_FRAME_TIMES[6] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[6] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[6];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_312
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_312(uint64_t now, uint64_t max_expire_time, MS_312* dest) const {
            if (LAST_FRAME_TIMES[7] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[7] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[7];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_308
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_308(uint64_t now, uint64_t max_expire_time, MS_308* dest) const {
            if (LAST_FRAME_TIMES[8] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[8] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[8];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_2F3
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_2F3(uint64_t now, uint64_t max_expire_time, MS_2F3* dest) const {
            if (LAST_FRAME_TIMES[9] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[9] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[9];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_268
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_268(uint64_t now, uint64_t max_expire_time, MS_268* dest) const {
            if (LAST_FRAME_TIMES[10] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[10] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[10];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_212
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_212(uint64_t now, uint64_t max_expire_time, MS_212* dest) const {
            if (LAST_FRAME_TIMES[11] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[11] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[11];
                return true;
            }
        }
            
        /** Sets data in pointer to MS_210
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_210(uint64_t now, uint64_t max_expire_time, MS_210* dest) const {
            if (LAST_FRAME_TIMES[12] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[12] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[12];
                return true;
            }
        }
            
        /** Sets data in pointer to CNG_ANZ
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_CNG_ANZ(uint64_t now, uint64_t max_expire_time, CNG_ANZ* dest) const {
            if (LAST_FRAME_TIMES[13] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[13] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[13];
                return true;
            }
        }
            
        /** Sets data in pointer to ADBLUE_DISP_RQ
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ADBLUE_DISP_RQ(uint64_t now, uint64_t max_expire_time, ADBLUE_DISP_RQ* dest) const {
            if (LAST_FRAME_TIMES[14] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[14] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[14];
                return true;
            }
        }
            
        /** Sets data in pointer to AAD_580
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_AAD_580(uint64_t now, uint64_t max_expire_time, AAD_580* dest) const {
            if (LAST_FRAME_TIMES[15] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[15] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[15];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[16];
		uint64_t LAST_FRAME_TIMES[16];
};
#endif // __ECU_MS_H_

#endif // EGS_SPRINTER_MODE