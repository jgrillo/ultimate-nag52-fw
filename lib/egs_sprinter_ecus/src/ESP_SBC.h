
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ESP_SBC'
*/

#ifdef EGS_SPRINTER_MODE

#ifndef __ECU_ESP_SBC_H_
#define __ECU_ESP_SBC_H_

#include <stdint.h>
    
#define TBCC_RS_CAN_ID 0x079E
#define BS_330_CAN_ID 0x0330
#define BS_328_CAN_ID 0x0328
#define BS_300_CAN_ID 0x0300
#define BS_270_CAN_ID 0x0270
#define BS_241_CAN_ID 0x0241
#define BS_208_CAN_ID 0x0208
#define BS_200_CAN_ID 0x0200
#define BS_119_CAN_ID 0x0119
#define BRK_STAT2_CAN_ID 0x005F
#define ART_258_CAN_ID 0x0258

/** Engine Running State */
enum class TBCC_RS_EngRun_Stat_TBCC {
	STOP = 0, // unknown
	START = 1, // unknown
	IDLE_UNSTBL = 2, // unknown
	IDLE_STBL = 3, // unknown
	UNLIMITED = 4, // unknown
	LIMITED = 5, // unknown
	NDEF6 = 6, // unknown
	SNA = 7, // unknown
};

/** Actual Minimum Engine Torque */
enum class TBCC_RS_EngTrqMin_TBCC {
	SNV = 255, // unknown
};

/** Brake Pedal State */
enum class TBCC_RS_BrkPdl_Stat_TBCC {
	UPSTOP = 0, // unknown
	PSD = 1, // unknown
	NDEF2 = 2, // unknown
};

/** Crackish Torque to Wheel Torque Ratio */
enum class TBCC_RS_EngWhlTrqRatio_TBCC {
	SNV = 255, // unknown
};

/** Actual Gear */
enum class TBCC_RS_Gr_TBCC {
	N = 0, // unknown
	D1 = 1, // unknown
	D2 = 2, // unknown
	D3 = 3, // unknown
	D4 = 4, // unknown
	D5 = 5, // unknown
	D6 = 6, // unknown
	D7 = 7, // unknown
	D8 = 8, // unknown
	D9 = 9, // unknown
	R = 11, // unknown
	P = 13, // unknown
	PWRFREE = 14, // unknown
	SNA = 15, // unknown
};

/** Vehicle longitudinal acceleration.focus */
enum class BS_330h_AX_S {
	SNV = 255, // unknown
};

/** Current Fzg. Mass */
enum class BS_330h_MASSE {
	SNV = 63, // unknown
};

/** brake pressure */
enum class BS_330h_P_BREMS {
	SNV = 255, // unknown
};

/** Vehicle longitudinal acceleration.focus */
enum class BS_328h_AX_S {
	SNV = 255, // unknown
};

/** Vehicle swing.The focus (+ = left) */
enum class BS_328h_AY_S {
	SNV = 255, // unknown
};

/** ESP error info */
enum class BS_328h_ESP_ERR {
	OK = 0, // unknown
	USPGF = 1, // unknown
	SNV = 7, // unknown
};

/** ESP display messages */
enum class BS_328h_ESP_DSPL_VAN {
	OK = 0, // unknown
	ESP_DEF = 1, // unknown
	ESP_OFF = 2, // unknown
	DIFF_GEARLOCK_SEL = 3, // unknown
	DIFF_GEARLOCK_AKT = 8, // unknown
	AAS_ESP_DEF = 9, // unknown
	AAS_ASR_ESP_DEF = 10, // unknown
	ASR_ESP_DEF = 12, // unknown
	AAS_ASR_BAS_ESP_DEF = 13, // unknown
	ALL_DEF = 16, // unknown
	ALL_DEF_GBV = 17, // unknown
	ALL_DIAG_GBV = 20, // unknown
	AAS_DEF = 28, // unknown
	SNV = 31, // unknown
};

/** Emergency opening AY */
enum class BS_328h_AY_NOTOEFF {
	AYLOW = 1, // unknown
	AYHIGH = 2, // unknown
	SNV = 3, // unknown
};

/** Pulse ring counter wheel front left (48 per revolution, 96 per revolution with ESP9 / BB9) */
enum class BS_328h_RIZ_VL {
	SNV = 255, // unknown
};

/** Pulse ring counter wheel front right (48 per revolution; 96 per revolution with ESP9 / BB9) */
enum class BS_328h_RIZ_VR {
	SNV = 255, // unknown
};

/** Send cycle time */
enum class BS_300h_T_Z {
	T20_0 = 1, // unknown
	T23_1 = 2, // unknown
	SNV = 3, // unknown
};

/** driver slows down */
enum class BS_300h_SFB {
	BREMSE_NEIN = 0, // unknown
	BREMSE_JA = 1, // unknown
	SNV = 3, // unknown
};

/** Ford.Engine torque */
enum class BS_300h_DM_ART {
	SNV = 255, // unknown
};

/** Ford.Engine torque */
enum class BS_300h_M_ESP {
	SNV = 255, // unknown
};

/** Rohsignal Gierrate without adjustment / filtering (+ = left) */
enum class BS_300h_GIER_ROH {
	SNV = 255, // unknown
};

/** Pulse ring counter wheel rear left (48 per revolution, 96 per revolution with ESP9 / BB9) */
enum class BS_270h_RIZ_HL {
	SNV = 255, // unknown
};

/** Pulse ring counter wheel rear right (48 per revolution, 96 per revolution with ESP9 / BB9) */
enum class BS_270h_RIZ_HR {
	SNV = 255, // unknown
};

/** Alerts PlatRollwarner */
enum class BS_270h_PRW_WARN {
	OK = 0, // unknown
	WARN_OHNE = 1, // unknown
	PRW_NV = 2, // unknown
	NEU_AKT = 3, // unknown
	WARN_VL = 4, // unknown
	WARN_VR = 5, // unknown
	WARN_HL = 6, // unknown
	WARN_HR = 7, // unknown
	SNV = 15, // unknown
};

/** Status PlatRollwarner */
enum class BS_270h_PRW_ST {
	EIN = 0, // unknown
	WARN = 1, // unknown
	AUS = 2, // unknown
	INIT = 3, // unknown
	PRW_NV = 6, // unknown
	SNV = 7, // unknown
};

/** negative pressure brake system */
enum class BS_241h_P_UNTER {
	SNV = 255, // unknown
};

/** Display Downhill Speed Regulation */
enum class BS_241h_DSR_Disp_Rq_VAN {
	IDLE = 0, // unknown
	DSR_RDY = 1, // unknown
	NDEF2 = 2, // unknown
	DSR_ON = 3, // unknown
};

/** Slope / slope of the road (+ gradient) */
enum class BS_241h_Rd_Slope {
	SNV = 255, // unknown
};

/** Sprocket, upper limit */
enum class BS_208h_GMAX_ESP {
	PASSIV = 0, // unknown
	G1 = 1, // unknown
	G2 = 2, // unknown
	G3 = 3, // unknown
	G4 = 4, // unknown
	G5 = 5, // unknown
	G6 = 6, // unknown
	G7 = 7, // unknown
};

/** Sprocket, lower limit */
enum class BS_208h_GMIN_ESP {
	PASSIV = 0, // unknown
	G1 = 1, // unknown
	G2 = 2, // unknown
	G3 = 3, // unknown
	G4 = 4, // unknown
	G5 = 5, // unknown
	G6 = 6, // unknown
	G7 = 7, // unknown
};

/** system condition */
enum class BS_208h_SZS {
	ERR_DIAG = 0, // unknown
	NORM = 1, // unknown
	N_DEF = 2, // unknown
	ABGAS = 3, // unknown
};

/** Switching shift ESP */
enum class BS_208h_SLV_ESP {
	SKL0 = 0, // unknown
	SKL1 = 1, // unknown
	SKL2 = 2, // unknown
	SKL3 = 3, // unknown
	SKL4 = 4, // unknown
	SKL5 = 5, // unknown
	SKL6 = 6, // unknown
	SKL7 = 7, // unknown
	SKL8 = 8, // unknown
	SKL9 = 9, // unknown
	SKL10 = 10, // unknown
	SKL11 = 11, // unknown
	SKL12 = 12, // unknown
	SKL13 = 13, // unknown
	SKL14 = 14, // unknown
	SKL15 = 15, // unknown
};

/** ESP request: 'n' insert */
enum class BS_208h_ANFN {
	ANF_N = 1, // unknown
	IDLE = 2, // unknown
	SNV = 3, // unknown
};

/** set braking torque (BR240 factor 1.8 larger) */
enum class BS_208h_MBRE_ESP {
	SNV = 255, // unknown
};

/** direction of rotation wheel rear right */
enum class BS_208h_DRTGHR {
	PASSIV = 0, // unknown
	VOR = 1, // unknown
	RUECK = 2, // unknown
	SNV = 3, // unknown
};

/** Rear wheel speed */
enum class BS_208h_DHR {
	SNV = 255, // unknown
};

/** direction of rotation wheel rear left */
enum class BS_208h_DRTGHL {
	PASSIV = 0, // unknown
	VOR = 1, // unknown
	RUECK = 2, // unknown
	SNV = 3, // unknown
};

/** Rear wheel speed */
enum class BS_208h_DHL {
	SNV = 255, // unknown
};

/** brake light switch */
enum class BS_200h_BLS {
	BREMSE_NBET = 0, // unknown
	BREMSE_BET = 1, // unknown
	SNV = 3, // unknown
};

/** rotary direction wheel front left */
enum class BS_200h_DRTGVL {
	PASSIV = 0, // unknown
	VOR = 1, // unknown
	RUECK = 2, // unknown
	SNV = 3, // unknown
};

/** wheel speed front left */
enum class BS_200h_DVL {
	SNV = 255, // unknown
};

/** direction of rotation wheel front right */
enum class BS_200h_DRTGVR {
	PASSIV = 0, // unknown
	VOR = 1, // unknown
	RUECK = 2, // unknown
	SNV = 3, // unknown
};

/** Right speed front right */
enum class BS_200h_DVR {
	SNV = 255, // unknown
};

/** Brake Torque Requested by Driver (NCV2 Ecle Resolution 3 Nm) */
enum class BRK_STAT2_BrkTrq_D {
	SNV = 255, // unknown
};

/** Actual Driving Brake Torque (I.e. Widout Brake Torque of Electrical Machine) */
enum class BRK_STAT2_BrkTrq_Van {
	SNV = 255, // unknown
};

/** ESP Operation State for Assistance Systems */
enum class BRK_STAT2_ESP_Oprtn_Stat_AS {
	NORM = 0, // unknown
	INIT = 1, // unknown
	DIAG = 2, // unknown
	EMT = 3, // unknown
	TBCC = 4, // unknown
	FLT = 5, // unknown
	CTRL_ACTV = 6, // unknown
	AMG_OFF = 7, // unknown
	OFF_AMG_SPORT = 8, // unknown
};

/** Request thrust shutdown suppression */
enum class BRK_STAT2_OFC_Supp_Rq_AS {
	IDLE = 0, // unknown
	SUPP = 1, // unknown
	ENBL = 2, // unknown
	SNV = 3, // unknown
};

/** Status Speed control at the test bench */
enum class BRK_STAT2_TBCC_Stat {
	TBCC_OFF = 0, // unknown
	TBCC_ON = 1, // unknown
	TBCC_REG_ACTV = 2, // unknown
	SNA = 3, // unknown
};

/** Art error code */
enum class ART_258h_ART_ERR {
	OK = 0, // unknown
	SCHMUTZ = 1, // unknown
	ART_DEF = 2, // unknown
	ART_LIM_DEF = 3, // unknown
	EXT = 4, // unknown
	DBC_DEF = 5, // unknown
	SCHMUTZ_DBC_DEF = 6, // unknown
	ART_DBC_DEF = 7, // unknown
	ART_LIM_DBC_DEF = 8, // unknown
	EXT_DBC = 9, // unknown
};

/** set type speed */
enum class ART_258h_V_ART {
	SNV = 255, // unknown
};

/** Assistance system Display request */
enum class ART_258h_ASSIST_ANZ_V2 {
	IDLE = 0, // unknown
	DBC_LIM = 1, // unknown
	DBC_AUS = 2, // unknown
	DBC_AUS_TON = 3, // unknown
	DBC_NV_AKT = 4, // unknown
	DBC_NV_LIM = 5, // unknown
	AAS_EIN = 6, // unknown
	AAS_AUS = 7, // unknown
	AAS_AUS_TON = 8, // unknown
	AAS_NV_LIM = 9, // unknown
	AAS_NV_OBJ = 10, // unknown
	AAS_NV_FBED = 11, // unknown
	AAS_FOLGEN = 12, // unknown
	AAS_OBJ_VERLUST = 13, // unknown
	AAS_OBJ_WECHSEL = 14, // unknown
	PAS_EIN = 15, // unknown
	PAS_AUS = 16, // unknown
	PAS_NV = 17, // unknown
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of TBCC_RS */
	uint32_t get_canid(){ return TBCC_RS_CAN_ID; }
    /** Sets Engine Running State */
    void set_EngRun_Stat_TBCC(TBCC_RS_EngRun_Stat_TBCC value){ raw = (raw & 0x1fffffffffffffff) | ((uint64_t)value & 0x7) << 61; }

    /** Gets Engine Running State */
    TBCC_RS_EngRun_Stat_TBCC get_EngRun_Stat_TBCC() const { return (TBCC_RS_EngRun_Stat_TBCC)(raw >> 61 & 0x7); }
        
    /** Sets Actual Minimum Engine Torque */
    void set_EngTrqMin_TBCC(TBCC_RS_EngTrqMin_TBCC value){ raw = (raw & 0xe000ffffffffffff) | ((uint64_t)value & 0x1fff) << 48; }

    /** Gets Actual Minimum Engine Torque */
    TBCC_RS_EngTrqMin_TBCC get_EngTrqMin_TBCC() const { return (TBCC_RS_EngTrqMin_TBCC)(raw >> 48 & 0x1fff); }
        
    /** Sets Brake Pedal State */
    void set_BrkPdl_Stat_TBCC(TBCC_RS_BrkPdl_Stat_TBCC value){ raw = (raw & 0xffff3fffffffffff) | ((uint64_t)value & 0x3) << 46; }

    /** Gets Brake Pedal State */
    TBCC_RS_BrkPdl_Stat_TBCC get_BrkPdl_Stat_TBCC() const { return (TBCC_RS_BrkPdl_Stat_TBCC)(raw >> 46 & 0x3); }
        
    /** Sets Actual Engine RPM. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: rpm) */
    void set_EngRPM_TBCC(uint16_t value){ raw = (raw & 0xffffc000ffffffff) | ((uint64_t)value & 0x3fff) << 32; }

    /** Gets Actual Engine RPM. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: rpm) */
    uint16_t get_EngRPM_TBCC() const { return (uint16_t)(raw >> 32 & 0x3fff); }
        
    /** Sets Mech. Parking Brake State */
    void set_MPkBrk_Stat_TBCC(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Mech. Parking Brake State */
    bool get_MPkBrk_Stat_TBCC() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Test Bench Cruise Control Enabled */
    void set_TBCC_Enbl(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Test Bench Cruise Control Enabled */
    bool get_TBCC_Enbl() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Crackish Torque to Wheel Torque Ratio */
    void set_EngWhlTrqRatio_TBCC(TBCC_RS_EngWhlTrqRatio_TBCC value){ raw = (raw & 0xffffffffc000ffff) | ((uint64_t)value & 0x3fff) << 16; }

    /** Gets Crackish Torque to Wheel Torque Ratio */
    TBCC_RS_EngWhlTrqRatio_TBCC get_EngWhlTrqRatio_TBCC() const { return (TBCC_RS_EngWhlTrqRatio_TBCC)(raw >> 16 & 0x3fff); }
        
    /** Sets Message Counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_MC_TBCC_RS(uint8_t value){ raw = (raw & 0xffffffffffff0fff) | ((uint64_t)value & 0xf) << 12; }

    /** Gets Message Counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_MC_TBCC_RS() const { return (uint8_t)(raw >> 12 & 0xf); }
        
    /** Sets Actual Gear */
    void set_Gr_TBCC(TBCC_RS_Gr_TBCC value){ raw = (raw & 0xfffffffffffff0ff) | ((uint64_t)value & 0xf) << 8; }

    /** Gets Actual Gear */
    TBCC_RS_Gr_TBCC get_Gr_TBCC() const { return (TBCC_RS_Gr_TBCC)(raw >> 8 & 0xf); }
        
    /** Sets CRC Checksum Byte 1 to 7 Accordinging to SAE J1850. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_CRC_TBCC_RS(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets CRC Checksum Byte 1 to 7 Accordinging to SAE J1850. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_CRC_TBCC_RS() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} TBCC_RS;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of BS_330 */
	uint32_t get_canid(){ return BS_330_CAN_ID; }
    /** Sets ABS disturbed */
    void set_RET_ABS_DEF(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets ABS disturbed */
    bool get_RET_ABS_DEF() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets ABH requirement 2 */
    void set_ABH_ANF_2(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets ABH requirement 2 */
    bool get_ABH_ANF_2() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets switch off the retarder */
    void set_RET_AUS(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets switch off the retarder */
    bool get_RET_AUS() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets ABH requirement 1 */
    void set_ABH_ANF_1(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets ABH requirement 1 */
    bool get_ABH_ANF_1() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets EBV defective indicator light */
    void set_EBV_KL(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets EBV defective indicator light */
    bool get_EBV_KL() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets start-up assist defective indicator light */
    void set_AAS_KL(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets start-up assist defective indicator light */
    bool get_AAS_KL() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets ASR defective indicator light */
    void set_ASR_KL(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets ASR defective indicator light */
    bool get_ASR_KL() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets switching suppression VG through ESP */
    void set_SCHALT_UNT_VG(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets switching suppression VG through ESP */
    bool get_SCHALT_UNT_VG() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets AAS deactivated */
    void set_AAS_DEAKT(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets AAS deactivated */
    bool get_AAS_DEAKT() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets bas deactivated */
    void set_BAS_DEAKT(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets bas deactivated */
    bool get_BAS_DEAKT() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets ROM deactivated */
    void set_ROM_DEAKT(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets ROM deactivated */
    bool get_ROM_DEAKT() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets ESP deactivated */
    void set_ESP_DEAKT(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets ESP deactivated */
    bool get_ESP_DEAKT() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets ASR deactivated */
    void set_ASR_DEAKT(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets ASR deactivated */
    bool get_ASR_DEAKT() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets ABS disabled */
    void set_ABS_DEAKT(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets ABS disabled */
    bool get_ABS_DEAKT() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets MSR deactivated */
    void set_MSR_DEAKT(bool value){ raw = (raw & 0xfffdffffffffffff) | ((uint64_t)value & 0x1) << 49; }

    /** Gets MSR deactivated */
    bool get_MSR_DEAKT() const { return (bool)(raw >> 49 & 0x1); }
        
    /** Sets abandoned */
    void set_RT_VERL(bool value){ raw = (raw & 0xfffeffffffffffff) | ((uint64_t)value & 0x1) << 48; }

    /** Gets abandoned */
    bool get_RT_VERL() const { return (bool)(raw >> 48 & 0x1); }
        
    /** Sets Vehicle longitudinal acceleration.focus */
    void set_AX_S(BS_330h_AX_S value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Vehicle longitudinal acceleration.focus */
    BS_330h_AX_S get_AX_S() const { return (BS_330h_AX_S)(raw >> 40 & 0xff); }
        
    /** Sets Current Fzg. Mass */
    void set_MASSE(BS_330h_MASSE value){ raw = (raw & 0xffffff03ffffffff) | ((uint64_t)value & 0x3f) << 34; }

    /** Gets Current Fzg. Mass */
    BS_330h_MASSE get_MASSE() const { return (BS_330h_MASSE)(raw >> 34 & 0x3f); }
        
    /** Sets Value Fzg.-Mass valid */
    void set_MASSE_IO(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets Value Fzg.-Mass valid */
    bool get_MASSE_IO() const { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets brake pressure */
    void set_P_BREMS(BS_330h_P_BREMS value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets brake pressure */
    BS_330h_P_BREMS get_P_BREMS() const { return (BS_330h_P_BREMS)(raw >> 24 & 0xff); }
        
    /** Sets Message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_BZ330h(uint8_t value){ raw = (raw & 0xffffffffff1fffff) | ((uint64_t)value & 0x7) << 21; }

    /** Gets Message counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_BZ330h() const { return (uint8_t)(raw >> 21 & 0x7); }
        
    /** Sets Request BMax Generator Voltage */
    void set_GenMax_ESP(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets Request BMax Generator Voltage */
    bool get_GenMax_ESP() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets ASS Enable */
    void set_SSA_Enbl_Rq_SBC(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets ASS Enable */
    bool get_SSA_Enbl_Rq_SBC() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets Ace switch off permanently due to a defect */
    void set_SSA_DsablPrmnt_Rq_SBC(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Ace switch off permanently due to a defect */
    bool get_SSA_DsablPrmnt_Rq_SBC() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets ASS Enable */
    void set_SSA_Enbl_Rq_AS(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets ASS Enable */
    bool get_SSA_Enbl_Rq_AS() const { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets Manual gearbox in neutral position (from ESP) */
    void set_NEUTRAL_ESP(bool value){ raw = (raw & 0xfffffffffffeffff) | ((uint64_t)value & 0x1) << 16; }

    /** Gets Manual gearbox in neutral position (from ESP) */
    bool get_NEUTRAL_ESP() const { return (bool)(raw >> 16 & 0x1); }
        
} BS_330;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of BS_328 */
	uint32_t get_canid(){ return BS_328_CAN_ID; }
    /** Sets Speed limit 2.length */
    void set_V_BEGR_ST2(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Speed limit 2.length */
    bool get_V_BEGR_ST2() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets ETS-regulated start */
    void set_ETS_ANF(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets ETS-regulated start */
    bool get_ETS_ANF() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Vehicle longitudinal acceleration.focus */
    void set_AX_S(BS_328h_AX_S value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Vehicle longitudinal acceleration.focus */
    BS_328h_AX_S get_AX_S() const { return (BS_328h_AX_S)(raw >> 48 & 0xff); }
        
    /** Sets Vehicle swing.The focus (+ = left) */
    void set_AY_S(BS_328h_AY_S value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Vehicle swing.The focus (+ = left) */
    BS_328h_AY_S get_AY_S() const { return (BS_328h_AY_S)(raw >> 40 & 0xff); }
        
    /** Sets ESP error info */
    void set_ESP_ERR(BS_328h_ESP_ERR value){ raw = (raw & 0xffffffc7ffffffff) | ((uint64_t)value & 0x7) << 35; }

    /** Gets ESP error info */
    BS_328h_ESP_ERR get_ESP_ERR() const { return (BS_328h_ESP_ERR)(raw >> 35 & 0x7); }
        
    /** Sets FSG: EHB-ASG in case of fallback */
    void set_INF_RFE_FSG(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets FSG: EHB-ASG in case of fallback */
    bool get_INF_RFE_FSG() const { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets line monitoring possible */
    void set_LTG_CHK_POS(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets line monitoring possible */
    bool get_LTG_CHK_POS() const { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets ESP display messages */
    void set_ESP_DSPL_VAN(BS_328h_ESP_DSPL_VAN value){ raw = (raw & 0xffffffffe0ffffff) | ((uint64_t)value & 0x1f) << 24; }

    /** Gets ESP display messages */
    BS_328h_ESP_DSPL_VAN get_ESP_DSPL_VAN() const { return (BS_328h_ESP_DSPL_VAN)(raw >> 24 & 0x1f); }
        
    /** Sets Emergency opening AY */
    void set_AY_NOTOEFF(BS_328h_AY_NOTOEFF value){ raw = (raw & 0xffffffffff9fffff) | ((uint64_t)value & 0x3) << 21; }

    /** Gets Emergency opening AY */
    BS_328h_AY_NOTOEFF get_AY_NOTOEFF() const { return (BS_328h_AY_NOTOEFF)(raw >> 21 & 0x3); }
        
    /** Sets Stop preventer at hazard braking */
    void set_SSA_EmgBrk_Actv(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets Stop preventer at hazard braking */
    bool get_SSA_EmgBrk_Actv() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets Open clutch */
    void set_KPL_OEF(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets Open clutch */
    bool get_KPL_OEF() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets Message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_BZ328h(uint8_t value){ raw = (raw & 0xfffffffffff8ffff) | ((uint64_t)value & 0x7) << 16; }

    /** Gets Message counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_BZ328h() const { return (uint8_t)(raw >> 16 & 0x7); }
        
    /** Sets Pulse ring counter wheel front left (48 per revolution, 96 per revolution with ESP9 / BB9) */
    void set_RIZ_VL(BS_328h_RIZ_VL value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets Pulse ring counter wheel front left (48 per revolution, 96 per revolution with ESP9 / BB9) */
    BS_328h_RIZ_VL get_RIZ_VL() const { return (BS_328h_RIZ_VL)(raw >> 8 & 0xff); }
        
    /** Sets Pulse ring counter wheel front right (48 per revolution; 96 per revolution with ESP9 / BB9) */
    void set_RIZ_VR(BS_328h_RIZ_VR value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Pulse ring counter wheel front right (48 per revolution; 96 per revolution with ESP9 / BB9) */
    BS_328h_RIZ_VR get_RIZ_VR() const { return (BS_328h_RIZ_VR)(raw >> 0 & 0xff); }
        
} BS_328;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of BS_300 */
	uint32_t get_canid(){ return BS_300_CAN_ID; }
    /** Sets Motor Moment Request Parity (straight parity) */
    void set_DMPAR_ART(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Motor Moment Request Parity (straight parity) */
    bool get_DMPAR_ART() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Motoroment request dynamic */
    void set_DMDYN_ART(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Motoroment request dynamic */
    bool get_DMDYN_ART() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Bas control active */
    void set_BAS_AKT(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Bas control active */
    bool get_BAS_AKT() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets full braking (ABS regulates all 4 wheels) */
    void set_VOLLBRE(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets full braking (ABS regulates all 4 wheels) */
    bool get_VOLLBRE() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets ESP giermom control active */
    void set_ESP_GIER_AKT(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets ESP giermom control active */
    bool get_ESP_GIER_AKT() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Motor Moment Request Parity (straight parity) */
    void set_MPAR_ESP(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Motor Moment Request Parity (straight parity) */
    bool get_MPAR_ESP() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets Motoroment request dynamic */
    void set_MDYN_ESP(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets Motoroment request dynamic */
    bool get_MDYN_ESP() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets drive torque control active */
    void set_AMR_AKT_ESP(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets drive torque control active */
    bool get_AMR_AKT_ESP() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets Send cycle time */
    void set_T_Z(BS_300h_T_Z value){ raw = (raw & 0xffe7ffffffffffff) | ((uint64_t)value & 0x3) << 51; }

    /** Gets Send cycle time */
    BS_300h_T_Z get_T_Z() const { return (BS_300h_T_Z)(raw >> 51 & 0x3); }
        
    /** Sets driver brakes parity (straight parity) */
    void set_SFB_PA(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets driver brakes parity (straight parity) */
    bool get_SFB_PA() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets driver slows down */
    void set_SFB(BS_300h_SFB value){ raw = (raw & 0xfffcffffffffffff) | ((uint64_t)value & 0x3) << 48; }

    /** Gets driver slows down */
    BS_300h_SFB get_SFB() const { return (BS_300h_SFB)(raw >> 48 & 0x3); }
        
    /** Sets Motor moments approach.Toggle 40ms + -10 */
    void set_DMTGL_ART(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Motor moments approach.Toggle 40ms + -10 */
    bool get_DMTGL_ART() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Motoroment request min */
    void set_DMMIN_ART(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Motoroment request min */
    bool get_DMMIN_ART() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Motoroment request max */
    void set_DMMAX_ART(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Motoroment request max */
    bool get_DMMAX_ART() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets Ford.Engine torque */
    void set_DM_ART(BS_300h_DM_ART value){ raw = (raw & 0xffffe000ffffffff) | ((uint64_t)value & 0x1fff) << 32; }

    /** Gets Ford.Engine torque */
    BS_300h_DM_ART get_DM_ART() const { return (BS_300h_DM_ART)(raw >> 32 & 0x1fff); }
        
    /** Sets Motor moments approach.Toggle 40ms + -10 */
    void set_MTGL_ESP(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Motor moments approach.Toggle 40ms + -10 */
    bool get_MTGL_ESP() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Motoroment request min */
    void set_MMIN_ESP(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Motoroment request min */
    bool get_MMIN_ESP() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Motoroment request max */
    void set_MMAX_ESP(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Motoroment request max */
    bool get_MMAX_ESP() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Ford.Engine torque */
    void set_M_ESP(BS_300h_M_ESP value){ raw = (raw & 0xffffffffe000ffff) | ((uint64_t)value & 0x1fff) << 16; }

    /** Gets Ford.Engine torque */
    BS_300h_M_ESP get_M_ESP() const { return (BS_300h_M_ESP)(raw >> 16 & 0x1fff); }
        
    /** Sets Rohsignal Gierrate without adjustment / filtering (+ = left) */
    void set_GIER_ROH(BS_300h_GIER_ROH value){ raw = (raw & 0xffffffffffff0000) | ((uint64_t)value & 0xffff) << 0; }

    /** Gets Rohsignal Gierrate without adjustment / filtering (+ = left) */
    BS_300h_GIER_ROH get_GIER_ROH() const { return (BS_300h_GIER_ROH)(raw >> 0 & 0xffff); }
        
} BS_300;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of BS_270 */
	uint32_t get_canid(){ return BS_270_CAN_ID; }
    /** Sets Pulse ring counter wheel rear left (48 per revolution, 96 per revolution with ESP9 / BB9) */
    void set_RIZ_HL(BS_270h_RIZ_HL value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Pulse ring counter wheel rear left (48 per revolution, 96 per revolution with ESP9 / BB9) */
    BS_270h_RIZ_HL get_RIZ_HL() const { return (BS_270h_RIZ_HL)(raw >> 56 & 0xff); }
        
    /** Sets Pulse ring counter wheel rear right (48 per revolution, 96 per revolution with ESP9 / BB9) */
    void set_RIZ_HR(BS_270h_RIZ_HR value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Pulse ring counter wheel rear right (48 per revolution, 96 per revolution with ESP9 / BB9) */
    BS_270h_RIZ_HR get_RIZ_HR() const { return (BS_270h_RIZ_HR)(raw >> 48 & 0xff); }
        
    /** Sets Alerts PlatRollwarner */
    void set_PRW_WARN(BS_270h_PRW_WARN value){ raw = (raw & 0xffff0fffffffffff) | ((uint64_t)value & 0xf) << 44; }

    /** Gets Alerts PlatRollwarner */
    BS_270h_PRW_WARN get_PRW_WARN() const { return (BS_270h_PRW_WARN)(raw >> 44 & 0xf); }
        
    /** Sets Status PlatRollwarner */
    void set_PRW_ST(BS_270h_PRW_ST value){ raw = (raw & 0xfffff8ffffffffff) | ((uint64_t)value & 0x7) << 40; }

    /** Gets Status PlatRollwarner */
    BS_270h_PRW_ST get_PRW_ST() const { return (BS_270h_PRW_ST)(raw >> 40 & 0x7); }
        
    /** Sets Message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_BZ270h(uint8_t value){ raw = (raw & 0xffffffffffff0fff) | ((uint64_t)value & 0xf) << 12; }

    /** Gets Message counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_BZ270h() const { return (uint8_t)(raw >> 12 & 0xf); }
        
    /** Sets ESP-OFF is active */
    void set_ESP_OFF_AKT(bool value){ raw = (raw & 0xfffffffffffff7ff) | ((uint64_t)value & 0x1) << 11; }

    /** Gets ESP-OFF is active */
    bool get_ESP_OFF_AKT() const { return (bool)(raw >> 11 & 0x1); }
        
} BS_270;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of BS_241 */
	uint32_t get_canid(){ return BS_241_CAN_ID; }
    /** Sets negative pressure brake system */
    void set_P_UNTER(BS_241h_P_UNTER value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets negative pressure brake system */
    BS_241h_P_UNTER get_P_UNTER() const { return (BS_241h_P_UNTER)(raw >> 56 & 0xff); }
        
    /** Sets HBC / VAC Indication Lamp on Request */
    void set_HBC_IndLmp_On_Rq(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets HBC / VAC Indication Lamp on Request */
    bool get_HBC_IndLmp_On_Rq() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets side wind assist brake intervention active */
    void set_BrkIntrvntn_Actv_CWA(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets side wind assist brake intervention active */
    bool get_BrkIntrvntn_Actv_CWA() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets Display Downhill Speed Regulation */
    void set_DSR_Disp_Rq_VAN(BS_241h_DSR_Disp_Rq_VAN value){ raw = (raw & 0xfff3ffffffffffff) | ((uint64_t)value & 0x3) << 50; }

    /** Gets Display Downhill Speed Regulation */
    BS_241h_DSR_Disp_Rq_VAN get_DSR_Disp_Rq_VAN() const { return (BS_241h_DSR_Disp_Rq_VAN)(raw >> 50 & 0x3); }
        
    /** Sets Slope / slope of the road (+ gradient) */
    void set_Rd_Slope(BS_241h_Rd_Slope value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Slope / slope of the road (+ gradient) */
    BS_241h_Rd_Slope get_Rd_Slope() const { return (BS_241h_Rd_Slope)(raw >> 0 & 0xff); }
        
} BS_241;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of BS_208 */
	uint32_t get_canid(){ return BS_208_CAN_ID; }
    /** Sets ESP / Art-Wish: 'Active recovering' */
    void set_AKT_R_ESP(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets ESP / Art-Wish: 'Active recovering' */
    bool get_AKT_R_ESP() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Sprocket, upper limit */
    void set_GMAX_ESP(BS_208h_GMAX_ESP value){ raw = (raw & 0xc7ffffffffffffff) | ((uint64_t)value & 0x7) << 59; }

    /** Gets Sprocket, upper limit */
    BS_208h_GMAX_ESP get_GMAX_ESP() const { return (BS_208h_GMAX_ESP)(raw >> 59 & 0x7); }
        
    /** Sets Sprocket, lower limit */
    void set_GMIN_ESP(BS_208h_GMIN_ESP value){ raw = (raw & 0xf8ffffffffffffff) | ((uint64_t)value & 0x7) << 56; }

    /** Gets Sprocket, lower limit */
    BS_208h_GMIN_ESP get_GMIN_ESP() const { return (BS_208h_GMIN_ESP)(raw >> 56 & 0x7); }
        
    /** Sets Suppression Dynamic fully detection */
    void set_DDYN_UNT(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Suppression Dynamic fully detection */
    bool get_DDYN_UNT() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets system condition */
    void set_SZS(BS_208h_SZS value){ raw = (raw & 0xff9fffffffffffff) | ((uint64_t)value & 0x3) << 53; }

    /** Gets system condition */
    BS_208h_SZS get_SZS() const { return (BS_208h_SZS)(raw >> 53 & 0x3); }
        
    /** Sets Tempomat operation */
    void set_TM_AUS(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets Tempomat operation */
    bool get_TM_AUS() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets Switching shift ESP */
    void set_SLV_ESP(BS_208h_SLV_ESP value){ raw = (raw & 0xfff0ffffffffffff) | ((uint64_t)value & 0xf) << 48; }

    /** Gets Switching shift ESP */
    BS_208h_SLV_ESP get_SLV_ESP() const { return (BS_208h_SLV_ESP)(raw >> 48 & 0xf); }
        
    /** Sets ESP brake engagement active */
    void set_BRE_AKT_ESP(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets ESP brake engagement active */
    bool get_BRE_AKT_ESP() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets ESP request: 'n' insert */
    void set_ANFN(BS_208h_ANFN value){ raw = (raw & 0xffff9fffffffffff) | ((uint64_t)value & 0x3) << 45; }

    /** Gets ESP request: 'n' insert */
    BS_208h_ANFN get_ANFN() const { return (BS_208h_ANFN)(raw >> 45 & 0x3); }
        
    /** Sets set braking torque (BR240 factor 1.8 larger) */
    void set_MBRE_ESP(BS_208h_MBRE_ESP value){ raw = (raw & 0xfffff000ffffffff) | ((uint64_t)value & 0xfff) << 32; }

    /** Gets set braking torque (BR240 factor 1.8 larger) */
    BS_208h_MBRE_ESP get_MBRE_ESP() const { return (BS_208h_MBRE_ESP)(raw >> 32 & 0xfff); }
        
    /** Sets direction of rotation wheel rear right */
    void set_DRTGHR(BS_208h_DRTGHR value){ raw = (raw & 0xffffffff3fffffff) | ((uint64_t)value & 0x3) << 30; }

    /** Gets direction of rotation wheel rear right */
    BS_208h_DRTGHR get_DRTGHR() const { return (BS_208h_DRTGHR)(raw >> 30 & 0x3); }
        
    /** Sets Rear wheel speed */
    void set_DHR(BS_208h_DHR value){ raw = (raw & 0xffffffffc000ffff) | ((uint64_t)value & 0x3fff) << 16; }

    /** Gets Rear wheel speed */
    BS_208h_DHR get_DHR() const { return (BS_208h_DHR)(raw >> 16 & 0x3fff); }
        
    /** Sets direction of rotation wheel rear left */
    void set_DRTGHL(BS_208h_DRTGHL value){ raw = (raw & 0xffffffffffff3fff) | ((uint64_t)value & 0x3) << 14; }

    /** Gets direction of rotation wheel rear left */
    BS_208h_DRTGHL get_DRTGHL() const { return (BS_208h_DRTGHL)(raw >> 14 & 0x3); }
        
    /** Sets Rear wheel speed */
    void set_DHL(BS_208h_DHL value){ raw = (raw & 0xffffffffffffc000) | ((uint64_t)value & 0x3fff) << 0; }

    /** Gets Rear wheel speed */
    BS_208h_DHL get_DHL() const { return (BS_208h_DHL)(raw >> 0 & 0x3fff); }
        
} BS_208;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of BS_200 */
	uint32_t get_canid(){ return BS_200_CAN_ID; }
    /** Sets Brake defective control lamp */
    void set_BRE_KL(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Brake defective control lamp */
    bool get_BRE_KL() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Bas defective control lamp */
    void set_BAS_KL(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Bas defective control lamp */
    bool get_BAS_KL() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets ESP Infoly lamp flashing light */
    void set_ESP_INFO_BL(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets ESP Infoly lamp flashing light */
    bool get_ESP_INFO_BL() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets ESP Infoly lamp */
    void set_ESP_INFO_DL(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets ESP Infoly lamp */
    bool get_ESP_INFO_DL() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets ESP defective control lamp */
    void set_ESP_KL(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets ESP defective control lamp */
    bool get_ESP_KL() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets ABS defective control lamp */
    void set_ABS_KL(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets ABS defective control lamp */
    bool get_ABS_KL() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Handbrake tightened (control lamp) */
    void set_HAS_KL(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Handbrake tightened (control lamp) */
    bool get_HAS_KL() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Brake light suppression (EBV_KL at 461/163 / T0 / T1N) */
    void set_BLS_UNT(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Brake light suppression (EBV_KL at 461/163 / T0 / T1N) */
    bool get_BLS_UNT() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets BLS Parity (straight parity) */
    void set_BLS_PA(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets BLS Parity (straight parity) */
    bool get_BLS_PA() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets Message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_BZ200h(uint8_t value){ raw = (raw & 0xffc3ffffffffffff) | ((uint64_t)value & 0xf) << 50; }

    /** Gets Message counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_BZ200h() const { return (uint8_t)(raw >> 50 & 0xf); }
        
    /** Sets brake light switch */
    void set_BLS(BS_200h_BLS value){ raw = (raw & 0xfffcffffffffffff) | ((uint64_t)value & 0x3) << 48; }

    /** Gets brake light switch */
    BS_200h_BLS get_BLS() const { return (BS_200h_BLS)(raw >> 48 & 0x3); }
        
    /** Sets rotary direction wheel front left */
    void set_DRTGVL(BS_200h_DRTGVL value){ raw = (raw & 0xffff3fffffffffff) | ((uint64_t)value & 0x3) << 46; }

    /** Gets rotary direction wheel front left */
    BS_200h_DRTGVL get_DRTGVL() const { return (BS_200h_DRTGVL)(raw >> 46 & 0x3); }
        
    /** Sets wheel speed front left */
    void set_DVL(BS_200h_DVL value){ raw = (raw & 0xffffc000ffffffff) | ((uint64_t)value & 0x3fff) << 32; }

    /** Gets wheel speed front left */
    BS_200h_DVL get_DVL() const { return (BS_200h_DVL)(raw >> 32 & 0x3fff); }
        
    /** Sets direction of rotation wheel front right */
    void set_DRTGVR(BS_200h_DRTGVR value){ raw = (raw & 0xffffffff3fffffff) | ((uint64_t)value & 0x3) << 30; }

    /** Gets direction of rotation wheel front right */
    BS_200h_DRTGVR get_DRTGVR() const { return (BS_200h_DRTGVR)(raw >> 30 & 0x3); }
        
    /** Sets Right speed front right */
    void set_DVR(BS_200h_DVR value){ raw = (raw & 0xffffffffc000ffff) | ((uint64_t)value & 0x3fff) << 16; }

    /** Gets Right speed front right */
    BS_200h_DVR get_DVR() const { return (BS_200h_DVR)(raw >> 16 & 0x3fff); }
        
} BS_200;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of BS_119 */
	uint32_t get_canid(){ return BS_119_CAN_ID; }
    /** Sets Request 1. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_REQUEST_1(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Request 1. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_REQUEST_1() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Request 2. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_REQUEST_2(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Request 2. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_REQUEST_2() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Request 3. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_REQUEST_3(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Request 3. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_REQUEST_3() const { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets Request 4. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_REQUEST_4(uint8_t value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets Request 4. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_REQUEST_4() const { return (uint8_t)(raw >> 32 & 0xff); }
        
    /** Sets Diagnosis block pointer. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_PTR_DIAG(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Diagnosis block pointer. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_PTR_DIAG() const { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets Message Counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_MSG_CNT_0(uint8_t value){ raw = (raw & 0xfffffffffffff0ff) | ((uint64_t)value & 0xf) << 8; }

    /** Gets Message Counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_MSG_CNT_0() const { return (uint8_t)(raw >> 8 & 0xf); }
        
    /** Sets Checksum. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_CRC_0(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Checksum. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_CRC_0() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} BS_119;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of BRK_STAT2 */
	uint32_t get_canid(){ return BRK_STAT2_CAN_ID; }
    /** Sets Enable RDU Request */
    void set_RDU_Enbl_Rq(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Enable RDU Request */
    bool get_RDU_Enbl_Rq() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Brake Intervention by Assistance System Active */
    void set_BrkIntrvntn_Actv_AS(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Brake Intervention by Assistance System Active */
    bool get_BrkIntrvntn_Actv_AS() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Brake Torque Requested by Driver (NCV2 Ecle Resolution 3 Nm) */
    void set_BrkTrq_D(BRK_STAT2_BrkTrq_D value){ raw = (raw & 0xf000ffffffffffff) | ((uint64_t)value & 0xfff) << 48; }

    /** Gets Brake Torque Requested by Driver (NCV2 Ecle Resolution 3 Nm) */
    BRK_STAT2_BrkTrq_D get_BrkTrq_D() const { return (BRK_STAT2_BrkTrq_D)(raw >> 48 & 0xfff); }
        
    /** Sets Actual Driving Brake Torque (I.e. Widout Brake Torque of Electrical Machine) */
    void set_BrkTrq_Van(BRK_STAT2_BrkTrq_Van value){ raw = (raw & 0xfffff000ffffffff) | ((uint64_t)value & 0xfff) << 32; }

    /** Gets Actual Driving Brake Torque (I.e. Widout Brake Torque of Electrical Machine) */
    BRK_STAT2_BrkTrq_Van get_BrkTrq_Van() const { return (BRK_STAT2_BrkTrq_Van)(raw >> 32 & 0xfff); }
        
    /** Sets ESP Operation State for Assistance Systems */
    void set_ESP_Oprtn_Stat_AS(BRK_STAT2_ESP_Oprtn_Stat_AS value){ raw = (raw & 0xffffffffc3ffffff) | ((uint64_t)value & 0xf) << 26; }

    /** Gets ESP Operation State for Assistance Systems */
    BRK_STAT2_ESP_Oprtn_Stat_AS get_ESP_Oprtn_Stat_AS() const { return (BRK_STAT2_ESP_Oprtn_Stat_AS)(raw >> 26 & 0xf); }
        
    /** Sets Message Counter. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_MC_BRK_STAT2(uint8_t value){ raw = (raw & 0xffffffffffff0fff) | ((uint64_t)value & 0xf) << 12; }

    /** Gets Message Counter. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_MC_BRK_STAT2() const { return (uint8_t)(raw >> 12 & 0xf); }
        
    /** Sets Request thrust shutdown suppression */
    void set_OFC_Supp_Rq_AS(BRK_STAT2_OFC_Supp_Rq_AS value){ raw = (raw & 0xfffffffffffff3ff) | ((uint64_t)value & 0x3) << 10; }

    /** Gets Request thrust shutdown suppression */
    BRK_STAT2_OFC_Supp_Rq_AS get_OFC_Supp_Rq_AS() const { return (BRK_STAT2_OFC_Supp_Rq_AS)(raw >> 10 & 0x3); }
        
    /** Sets Status Speed control at the test bench */
    void set_TBCC_Stat(BRK_STAT2_TBCC_Stat value){ raw = (raw & 0xfffffffffffffcff) | ((uint64_t)value & 0x3) << 8; }

    /** Gets Status Speed control at the test bench */
    BRK_STAT2_TBCC_Stat get_TBCC_Stat() const { return (BRK_STAT2_TBCC_Stat)(raw >> 8 & 0x3); }
        
    /** Sets CRC Checksum Byte 1 to 7 Accordinging to SAE J1850. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_CRC_BRK_STAT2(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets CRC Checksum Byte 1 to 7 Accordinging to SAE J1850. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_CRC_BRK_STAT2() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} BRK_STAT2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ART_258 */
	uint32_t get_canid(){ return ART_258_CAN_ID; }
    /** Sets Turn the display on type display */
    void set_ART_DSPL_EIN(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Turn the display on type display */
    bool get_ART_DSPL_EIN() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Warning Number */
    void set_ART_MAX_SUM(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Warning Number */
    bool get_ART_MAX_SUM() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Art Warnington */
    void set_ART_WT(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Art Warnington */
    bool get_ART_WT() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Art Infolampe */
    void set_ART_INFO(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Art Infolampe */
    bool get_ART_INFO() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Art error code */
    void set_ART_ERR(ART_258h_ART_ERR value){ raw = (raw & 0xf0ffffffffffffff) | ((uint64_t)value & 0xf) << 56; }

    /** Gets Art error code */
    ART_258h_ART_ERR get_ART_ERR() const { return (ART_258h_ART_ERR)(raw >> 56 & 0xf); }
        
    /** Sets set type speed */
    void set_V_ART(ART_258h_V_ART value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets set type speed */
    ART_258h_V_ART get_V_ART() const { return (ART_258h_V_ART)(raw >> 48 & 0xff); }
        
    /** Sets Display 'Winter tire limit reached' on the display */
    void set_ART_DSPL_PGB(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Display 'Winter tire limit reached' on the display */
    bool get_ART_DSPL_PGB() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Display 'DTR from [0]' on the display */
    void set_ART_VFBR(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Display 'DTR from [0]' on the display */
    bool get_ART_VFBR() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Display '---' on the display */
    void set_ART_DSPL_LIM(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Display '---' on the display */
    bool get_ART_DSPL_LIM() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Spacer control mpomat turned on */
    void set_ART_EIN(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets Spacer control mpomat turned on */
    bool get_ART_EIN() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets Turn on style segment display */
    void set_ART_SEG_EIN(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Turn on style segment display */
    bool get_ART_SEG_EIN() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets Speed indicator flash */
    void set_ART_DSPL_BL(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets Speed indicator flash */
    bool get_ART_DSPL_BL() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets Art Tempomat on */
    void set_TM_EIN_ART(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets Art Tempomat on */
    bool get_TM_EIN_ART() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets Minimum display time in the display new trigger */
    void set_ART_DSPL_NEU(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Minimum display time in the display new trigger */
    bool get_ART_DSPL_NEU() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets Art is overplayed by the driver */
    void set_ART_UEBERSP(bool value){ raw = (raw & 0xffffffffffffbfff) | ((uint64_t)value & 0x1) << 14; }

    /** Gets Art is overplayed by the driver */
    bool get_ART_UEBERSP() const { return (bool)(raw >> 14 & 0x1); }
        
    /** Sets Assistance system Display request */
    void set_ASSIST_ANZ_V2(ART_258h_ASSIST_ANZ_V2 value){ raw = (raw & 0xffffffffffffffe0) | ((uint64_t)value & 0x1f) << 0; }

    /** Gets Assistance system Display request */
    ART_258h_ASSIST_ANZ_V2 get_ASSIST_ANZ_V2() const { return (ART_258h_ASSIST_ANZ_V2)(raw >> 0 & 0x1f); }
        
} ART_258;



class ECU_ESP_SBC {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case TBCC_RS_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case BS_330_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case BS_328_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case BS_300_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case BS_270_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case BS_241_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                case BS_208_CAN_ID:
                    LAST_FRAME_TIMES[6] = timestamp_now;
                    FRAME_DATA[6] = value;
                    return true;
                case BS_200_CAN_ID:
                    LAST_FRAME_TIMES[7] = timestamp_now;
                    FRAME_DATA[7] = value;
                    return true;
                case BS_119_CAN_ID:
                    LAST_FRAME_TIMES[8] = timestamp_now;
                    FRAME_DATA[8] = value;
                    return true;
                case BRK_STAT2_CAN_ID:
                    LAST_FRAME_TIMES[9] = timestamp_now;
                    FRAME_DATA[9] = value;
                    return true;
                case ART_258_CAN_ID:
                    LAST_FRAME_TIMES[10] = timestamp_now;
                    FRAME_DATA[10] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to TBCC_RS
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_TBCC_RS(uint64_t now, uint64_t max_expire_time, TBCC_RS* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to BS_330
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_330(uint64_t now, uint64_t max_expire_time, BS_330* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to BS_328
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_328(uint64_t now, uint64_t max_expire_time, BS_328* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to BS_300
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_300(uint64_t now, uint64_t max_expire_time, BS_300* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
        /** Sets data in pointer to BS_270
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_270(uint64_t now, uint64_t max_expire_time, BS_270* dest) const {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[4] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[4];
                return true;
            }
        }
            
        /** Sets data in pointer to BS_241
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_241(uint64_t now, uint64_t max_expire_time, BS_241* dest) const {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[5] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[5];
                return true;
            }
        }
            
        /** Sets data in pointer to BS_208
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_208(uint64_t now, uint64_t max_expire_time, BS_208* dest) const {
            if (LAST_FRAME_TIMES[6] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[6] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[6];
                return true;
            }
        }
            
        /** Sets data in pointer to BS_200
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_200(uint64_t now, uint64_t max_expire_time, BS_200* dest) const {
            if (LAST_FRAME_TIMES[7] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[7] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[7];
                return true;
            }
        }
            
        /** Sets data in pointer to BS_119
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BS_119(uint64_t now, uint64_t max_expire_time, BS_119* dest) const {
            if (LAST_FRAME_TIMES[8] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[8] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[8];
                return true;
            }
        }
            
        /** Sets data in pointer to BRK_STAT2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_BRK_STAT2(uint64_t now, uint64_t max_expire_time, BRK_STAT2* dest) const {
            if (LAST_FRAME_TIMES[9] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[9] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[9];
                return true;
            }
        }
            
        /** Sets data in pointer to ART_258
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ART_258(uint64_t now, uint64_t max_expire_time, ART_258* dest) const {
            if (LAST_FRAME_TIMES[10] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now - LAST_FRAME_TIMES[10] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[10];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[11];
		uint64_t LAST_FRAME_TIMES[11];
};
#endif // __ECU_ESP_SBC_H_

#endif // EGS_SPRINTER_MODE